:d:A collection of thoughts on the topic of software product design, as well as its potential methodologies.
:k:Software Product, Product Design, Software Design, Life Simulator, Tamagotchi, Electronic Gadget, Software Toy, Automata, User Experience, UI, UX, EduTech, Entertainment, Indie Development
:l:2025-02-28

[Designing a Software Product] January 21, 2025 - February 28, 2025

This is a collection of my personal thoughts on the design of a software product.

@@<hr>
<001>
@@<h3><b>1. Where to Begin</b></h3>

Imagine that you are trying to design a software product. Depending on your field of interest, it could be a game, a social networking service, a chatbot, an educational platform, or something else.

No matter what type of product you have in mind, however, we can all agree that it ought to be something meaningful. And by "meaningful", I mean a set of qualitative measures which transcend a mere assortment of dry, mechanistic details.

When designing a software, it is necessary to resolve a gap between the product's end goal and its implementation details. We can surmount this difficulty via quantitative reasoning.

For example, suppose that we are trying to create a pet simulator (similar to Tamagotchi). What shall we do to fulfill such an objective?

First, we need to devise a list of meaningful pet-related experiences. In addition, we need to figure out how to translate them into computational procedures (because they must be part of a computer program).

We can achieve this by defining our pet simulator not in terms of vague emotional descriptions, but in terms of numerical quantities.

@@<hr>
<002>
@@<h3><b>2. Quantification of Meaning</b></h3>

The question is, what kinds of numerical quantities do we want in our pet simulator?

This is where the problem of ambiguity arises. Overcoming this initial barrier is crucial for the sake of designing something meaningful.

To kick-start the design process, let me come up with a couple of ideas. The very first thing which crosses my mind is that the pet needs food to survive.

Whenever the pet eats something, its energy level increases. If it doesn't eat anything, its energy level will gradually drop.

What comes next? Let me guess. Note that food is not the only biological need. For example, the pet also needs to be caressed to feel that it is being loved.

For prototyping purposes, then, it will be sensible to add a pair of buttons to let us interact with the pet - one for feeding, and the other one for caressing. Clicking the former will increase the energy level, while clicking the latter will increase the affection level.

Here, we can see an example of a dilemma between two choices. While we are feeding the pet, it cannot be caressed. And while we are caressing the pet, it cannot be fed.

@@<hr>
<003>
@@<h3><b>3. The Geometry of Variables</b></h3>

The design of a virtual pet, then, can be summarized as the following two steps:

(1) Create a set of variables, each of which represents a unique aspect of the pet's state.
(2) Create a set of actions, which either increment or decrement these variables when invoked.

The act of feeding, for instance, may greatly amplify the pet's energy level but slightly reduce its affection level. The act of caressing, on the other hand, may greatly amplify the pet's affection level but slightly reduce its energy level.

And if we spend time without doing anything, both the pet's energy and affection levels can be expected to decay as time passes by.

The dynamics of pet simulation can be easily visualized. For example, we can treat the pet's current state as a particle on a 2D plane, whose axes denote the pet's energy and affection levels, respectively.

Each action, then, will be interpreted as a force which pushes the particle in a specific direction.

@@<hr>
<004>
@@<h3><b>4. Multiple Agents</b></h3>

So, it looks like introducing a few variables and means of manipulating them will let us create a simple pet simulator.

This solution, however, is restrictive in the sense that it does not scale. If we are to stick solely to the idea of raising a single pet, the horizon of our experience will forever be constrained to that of a cheap electronic toy, such as Tamagotchi.

There is a way to overcome such a barrier, though. All we have to do is provide the user with multiple pets instead of just one. This will open up a door to a richer spectrum of choices, without necessitating us to invent anything new.

From a game design point of view, such a means of scaling introduces the notion of progression. By adding more and more pets to the inventory, the user is now able to participate in a mission towards continual improvement.

This is an indispensable feature to have, as it is necessary to ensure that the user won't run out of goals to pursue.

@@<hr>
<005>
@@<h3><b>5. Relations</b></h3>

Previously, we saw that letting the user own multiple pets (instead of just one) neatly solves the scaling issue.

If pets are unable to interact with each other, however, the overall experience will be too flat and boring.

One way to solve this is to invent a variable which describes not just a single pet, but a relationship between two pets.

For example, we may come up with a new variable which represents the degree of jealousy that a pet feels towards another pet. We will then be able to declare a rule such as: "Pet A becomes more jealous towards pet B whenever the user caresses B in front of A".

The main benefit of this is that it introduces a wide variety of dynamic behaviors to the system. Too much jealousy, for instance, may trigger a pet to start a fight with another pet, resulting in mutual damage.

Such a conflict of interests serves as an important factor in the design of subtle narratives. It urges the user to make choices carefully, since each choice may incur a catastrophic side effect.

@@<hr>
<006>
@@<h3><b>6. Partitioning</b></h3>

We may imagine a pet simulator as a network of pets and their relationships.

If every pet is capable of interacting with every other pet at any given moment, however, the whole system will plunge into chaos.

The most effective solution to this is to partition our simulation space into rooms that are separate from each other, meaning that pets in one room won't be able to interact with those in another room.

Such a mechanic allows us to create local environments, each of which is imbued with its own personality. It also provides the user with an extra dimension of self inquiry, such as: "Should I put these two pets in the same room? They might fight with each other."

Another advantage is that it makes things more digestible. By splitting a large herd of pets into isolated groups, the user is now only required to pay attention to a handful of them at a time, rather than having to monitor the entire community of pets like an omniscient deity.

@@<hr>
<007>
@@<h3><b>7. Modes of Interaction</b></h3>

The richness of user experience can be further amplified by splitting it into multiple channels.

In our pet simulator, for example, the user might be allowed to not only take care of one's pets, but also send them to schools, consult a vet, visit a local pet shop, and so on. Since these activities differ from each other significantly, we may assume that they belong to separate classes.

The overall structure of the UI, then, could be depicted as a list of global menu options. Each of them, when clicked, will bring the user to a distinct local space, equipped with its own category of user interactions.

The exact layout of this sort of UI may vary, of course, depending on what kind of product it is intending to convey.

What is noteworthy, though, is the fact that it prevents confusion by neatly segmenting the system into specialized modules, each of which focuses on its own topic and nothing else.

@@<hr>
<008>
@@<h3><b>8. UI State VS System State</b></h3>

When we think about a software product as a state machine (as in automata theory), we quickly come to the conclusion that it consists of two distinct types of state - one which is bound to user interaction (aka "UI State"), and the other one which is bound to the system's internal dynamics (aka "System State").

The UI state mirrors the way in which the user is currently interacting with the app's virtual world. The dimensions of the viewport (i.e. camera), the position of the page's scollbar, the current menu selection, and the like, are all parts of the application's UI state. They do not directly influence things that are happening in the world.

The System state, on the other hand, refers to the current state of the world itself. In our pet simulator, for example, the individual pets' positions and energy/affection levels should all be taken as parts of the application's System state because they all contribute to what is happening inside the world.

@@<hr>
<009>
@@<h3><b>9. State Hierarchy</b></h3>

A software product, regardless of its kind, possesses its own state. An important concept to keep in mind is that the state itself may be broken down to smaller states, each of which can then be broken down to even smaller states, and so on.

Eventually, this sort of breakdown reveals its own hierarchical structure.

Based on this kind of reasoning, we can easily design the entire tree of states from a top-down perspective. All we need to do is first define a few general state objects, and then describe each of them as a collection of more specific state objects, and so forth.

What is interesting is that there are direct one-to-one mappings between states which are equivalent but designed to serve different purposes.

The state of the UI which displays the current hunger level of a virtual pet, for instance, could be bound to reflect the actual hunger level of the pet to which it corresponds. This is an example of "UI binding" - a recurring concept in the domain of reactive programming.








:d:A collection of memes that are formatted in a rather technical manner.
:k:Memes, Visual Language, Diagram, Schematic, Math, Graph, Visualization, Graphical Language, Systems Engineering, Industrial Engineering, Engineering Math
:l:2025-02-14

[Technical Memes] February 2, 2025 - February 14, 2025

@@<hr>
@@<h3><b>Four Quadrants of Sleep</b></h3>

<t01>

@@<hr>
@@<h3><b>Caffeine Crafting Rules</b></h3>

<t02>

@@<hr>
@@<h3><b>English Breakfast</b></h3>

<t03>

@@<hr>
@@<h3><b>Five Phases of Game Development</b></h3>

<t04>









:d:A list of archetypes which appear commonely in popular media, including literature, film, games, and other forms of storytelling.
:k:Archetypes, Jung, Analytical Psychology, Psychoanalysis, Collective Unconscious, Subconscious, Symbolism, Semantics, Game Design, Game Development, Game Narratives, Mandala, Semiotics
:l:2025-03-16

[Archetypes of Play] February 7, 2025 - March 16, 2025

The following symbolic elements are some of the most popular archetypes of play, frequently recurring in various forms of entertainment such as video games, tabletop games, films, literature, and others.

@@<hr>
<a01>
@@<h3><b>1. Doll</b></h3>

A doll is a special object. It is inanimate from a functional point of view, yet it is nevertheless endowed with the appearances of an animate being. In a way, therefore, a doll plays the role of a mediator between the realm of life (spirits) and the realm of death.

A doll is a piece of dead matter which is given its own spirit. The spirit lets the doll come alive as its own quasi-living thing. The act of fabricating a doll and giving it a name (identity), therefore, tears the boundary between the overworld and the underworld, giving birth to a "middle region" in which both the live and dead come together and establish a meaningful symbiosis. This place is an intersection between soul and matter.

Dolls can be found in a variety of forms in today's free market. A consumer good, for instance, is a doll which is imbued with the brand's spirit. Some people choose to buy goods of a specific brand because they assign metaphysical meanings to it, other than the pragmatic implication of the product's mere material composition.

Shopping, therefore, could be imagined as a process of furnishing one's own inventory of dolls - an intricate collection of enchanted icons, ready to connect the consumer's identity to the edge of reality where the distinction between the real and unreal blurs itself.

(Keywords: #PsychicInterface #Identity #Icon #Idol #Simulacrum #Toy #Plaything)

@@<hr>
<a02>
@@<h3><b>2. Treasure Box</b></h3>

A treasure box is full of hidden wonders. The moment you open it up, it may present you with either a pleasant surprise (reward) or punishment. It is a box of mystery, and you never know what kind of thing will reveal itself until you decide to open it.

The core mechanic of a treasure box is random reward, driven by the principle of uncertainty. The act of disclosing it brings you either a good luck or bad luck, and such an outcome is determined by pure chance and not by your personal will. It is a game of randomness.

This hypothetical box shows up in different forms across a variety of cases. In the context of mining, it could be a chunk of dirt and stone beyond which precious minerals might be hidden. In the context of fishing, it could be an opaque pond in which you might be able to catch a fish. And in the context of gambling, you could imagine it as a slot machine.

In every one of the aforementioned scenarios, though, the essence of what constitutes a treasure box stays the same. It is basically an "enclosure of a secret" - a nutshell, when cracked open, throws you upon an unexpected line of destiny. And the way to open it usually involves just a simple kind of action, such as digging the ground with a pickaxe, casting a fishing rod, or pulling the lever of a slot machine.

(Keywords: #RandomReward #PleasantSurprise #Uncertainty #Probability #StochasticProcesses #ParallelUniverse)

@@<hr>
<a03>
@@<h3><b>3. Portal</b></h3>

A portal is a gateway to another world - a special device of magic which lets the user "cross the threshold" to the other side of reality. It is an awkward puncture in the midst of our mundane everyday life. In literature as well as popular media, it serves as a means of scene transition.

An adventure usually begins by entering a portal, which is typically concealed in a long neglected corner of a place. It could be a door, a looking glass, a closet, an elevator, a storm, or any other "hole" in physical dimension which is capable of temporarily splitting the continuum of our living space into two binary regions - "here" (i.e. the world with which we are familiar) and "there" (i.e. the world which is unknown and full of mysteries).

By crossing a portal, one faces a major shift in one's life due to the sudden disappearance of friendly elements from one's environment. The other side of the portal presents the visitor with a whole new spectrum of paradigms, most of which defy the expectations of one's prior knowledge and education.

A portal opens up a door to a whole new space of possibilities and exploration. In a way, therefore, it provides us with inexplicable catharsis - a sense of spiritual liberation from the confines of ordinary life. In the prolonged absence of such a portal, we usually fabricate one by planning a travel, engaging in an unusual outdoor activity, or studying an unfamiliar subject.

(Keywords: #AnotherWorld #LandOfMysteries #Liberation #RoomForExploration #Adventure)

@@<hr>
<a04>
@@<h3><b>4. Furnace</b></h3>

A furnace is a melting pot of chaotic rigmaroles. It is a crucible governed by primordial fire, which disassembles the well-established structure of its ingredients and concocts their inner organs into a bizarrely morphed form. It is a place of rebirth - a transformation from one state to another.

What would a furnace signify from a functional standpoint? There could be many interpretations, but one thing which is worthy of remark is that it allows multiple elements to come together and fuse into a whole separate entity. Thus, we can imagine that a furnace is a cradle of interactions and their unforeseen consequences.

One of the key takeaways of such synthesis is the very notion of unexpectedness. Familiar elements, when combined, sometimes merge into a surprising result which may either bless or destroy the creator. This queer sort of jumpscare, emerging off of the middle of one's otherwise ordinary experience, introduces a sudden "turn" in our familiar storyline, thereby reshaping the perfectly logic-driven clockwork universe into one which is interleaved with caverns of lurking chaos.

(Keywords: #Crafting #Alchemy #Mixer #Combination #Relations #Interactions)

@@<hr>
<a05>
@@<h3><b>5. Light</b></h3>

Light is an essential ingredient of visibility. We need it in order to observe our surroundings, gather information, and draw a picture of where we are and what kinds of things wait before us. Its presence ensures the overcoming of darkness - an indispensable precondition of knowledge.

It is our instinct to struggle to learn more and more about the environment in which we live. And the root of such an innate tendency can be traced back to the evolutionary fact that the more we know, the more likely we will manage to survive in this hostile world which is full of hidden dangers.

This also explains why darkness is a common element of horror in literature, as well as other forms of media such as films, games, etc. Fear originates from the unknown, and the lack of one's capacity to explain things that are happening nearby. By covering our eyes with the veil of ignorance, darkness renders us vulnerable against the phantasmagoria of potential threats.

The very moment we turn on a source of light, this chamber of uncertainty dissolves itself into oblivion and lets us surmount the unfounded fear which has been haunting us. Light, therefore, is a symbol of courage, grounded upon the promise that everything is and will stay lit in our field of vision.

(Keywords: #Unveiling #OvercomingOfDarkness #Enlightenment #Knowledge #Discovery)

@@<hr>
<a06>
@@<h3><b>6. Compass</b></h3>

Everyone longs to discover the ultimate purpose in life. Everyone searches for a direction whenever a mist of uncertainty surrounds them. And whenever such a sentiment is being recognized, a spiritual guidance comes into play and saves the day.

A compass is what we need whenever we are lost in the thin air of motivational void. Being a direction-provider, a compass often symbolizes our hope for a parental figure who will lead us to a sequence of persistent goals as well as means to achieve them.

A compass gives us a sense of purpose - a belief that the peak of the mountain to which it is pointing is somewhere worth reaching. It gives us a reason to stay alive and continually strive to become a better version of ourselves every morning, for the hope of getting closer and closer to our ideal destination. It is what endows even the most trivial of our actions with its own meaning.

It can also be understood that a compass only provides us with a fragmentary view of a more holistic vision, which is represented by a map. A map is an overall outline (i.e. a bigger picture) of a panorama of goals that are waiting to be accomplished and how they should be approached. Since such a map can be too complex to read, however, a compass is often preferred when it comes to helping the user focus on one goal at a time, on a step-by-step basis.

(Keywords: #Purpose #Pathway #Journey #Direction #Goal #Guidance #Mentor)

@@<hr>
<a07>
@@<h3><b>7. Fountain</b></h3>

A fountain is a source of life. It is the ultimate birthplace where everything comes into existence, by means of its unrestricted supply of water. Through its life-giving agency, a fountain provides the world with seeds of fertility which will eventually grow into a jungle of living matters.

Such a place of initial creation is an indispensable element to have in a narrative universe, which promises to begin its genealogy of events with its own story.

A universe, filled with its own system of meaningful causes and their correspondingly meaningful consequences, must start by telling a story at some point in time. And in order to do that, it needs to have a point of origin - the place where the hero's journey begins, the evil of the world unveils, and the ensemble of earthly matters sprout and fill up the void of space, ready to unfold their secrets before the eyes of the adventurer.

In a static, desert-like environment, we can easily imagine such a place of origin as a fountain. Once we introduce water to dry land, life starts to grow and populate its silent horizons. This is the moment at which dynamism comes into play and transforms the land into a colossal "engine" of the storyline, which henceforth drives the pangs and joys of the drama and the way they relate themselves with one another.

(Keywords: #NewLife #Spawner #Birth #NewPossibilities #Hope #NewLight)

@@<hr>
<a08>
@@<h3><b>8. Building Blocks</b></h3>

Building blocks make up the essence of our creative freedom. They are the very flesh and bones of which the landscape of our living area is made. By means of building blocks, we are able to devise all sorts of architectural wonders each of which may be imbued with its own practical and/or aesthetic features.

While the most basic building blocks are purely structural (i.e. They are static and idle objects which do not actively interact with their surroundings), we may also discover dynamic ones which are capable of displaying their own characteristic behaviors when exposed to certain conditions. An automatic door, for instance, will open itself up whenever somebody comes in front of it.

In a way, therefore, building blocks serve as the core components of the world and its dynamic system. Their particular arrangement may trigger the emergence of a series of particular events, which in turn may modify the original arrangement which triggered those events in the first place. Such a cyclic pattern of interaction signals the birth of an emergent system, which evolves over time by means of a recurring feedback loop and self-adaptation.

(Keywords: #Assembly #Construction #Emergence #Modularity #CreativeFreedom #Reductionism)

@@<hr>
<a09>
@@<h3><b>9. Cabinet of Curiosities</b></h3>

There are multiple universes in our mental landscape. As imaginative beings, we all possess "bubbles" of ideas within the deep waters of our psychic realm. Each of these bubbles is a fictional world, governed by its own laws of nature and populated by its own families of both animate and inanimate entities.

A cabinet of curiosities, which is an assortment of scientific wonders gathered from the nature, is a symbol of such a fictional universe which serves as a fuel for one's creative endeavors. As there are multiple cabinets across different rooms and buildings, a person, too, carries an entire museum of miniature universes in one's mind.

Some of these inner spheres of imagination might be collective in nature, meaning that many of us share significant portions of them as part of our culture. If you and I have read the same fantasy novel, for example, we would be sharing more or less the same world which is being depicted by that novel.

Popular media, as well as their myriad genres of entertainment, comprise a dense network of imaginary spaces, each of which possesses its own share of virtual citizens including fans, critics, and other types of audiences. Depending on how the media's narratives unfold, such spaces may freely merge, split, grow, or shrink as time passes by, as though they are celestial bodies in outerspace.

(Keywords: #CollectiveExperience #SharedUniverse #Library #Museum #ScientificInquiry #Taxonomy #CollectiveUnconscious)

@@<hr>
<a10>
@@<h3><b>10. City</b></h3>

From the megalithic city of Babylon to modern day metropolis, cities have been the symbol of spiritual dissonance and inner nihilism. Unlike a small neighborhood in which you are honored as an irreplaceable member of the community, a city is an unfathomably gigantic, cold, inhuman vacuum in which you will hardly find a home.

A busy metropolitan city is a center of prosperity. However, it is also a place in which individuality is utterly crushed under the weight of the populace. The city's densely populated urban areas are full of cheap, dispensable workers, constantly being told that they are nothing more than mere lines on a chart, ready to be erased the moment they are deemed useless.

Therefore, it is not hard to understand why so many forms of contemporary media, including novels, games, and films, often depict the city as the ultimate enemy of mankind in today's world.

A hero in our modern life is no longer a muscular warrior who fights in a battlefield or partakes in a journey to the wilderness. Instead, it is the kind of individual who is meek yet not afraid to build a kingdom of infinite space in the midst of this shallow, crowded world - someone who possesses a courage to stand up against the city's bloodless apathy and its callous breath to wipe everybody's dignity out of existence.

(Keywords: #Metropolis #Babylon #ModernLife #Hitchhiker #Globalism #Internet #Wired #Hyperconnectivity)

@@<hr>
<a11>
@@<h3><b>11. Word</b></h3>

The power of a word is immeasurable. A word is a point of intersection between the material and psychic realms, serving as an interface via which feelings can be transmitted. Whenever you say a word, you are breathing a portion of your soul into that word, turning it into a carrier of a spirit.

A spirit might be thought of as a "piece of information" from a scientific standpoint. It means that we should consider a word as a volume in space which is able to be possessed by a spirit, and remain so as long as it stays legible.

By means of words, we share our spirits with those who decide to read them. And the swiftness of such a process is determined by how vividly each word depicts its corresponding spirit, as well as how compatible it is with the reader's system of thoughts.

In this sense, a computer may be imagined as a "spirit-processing machine" which inhales a stream of words (i.e. commands), rearranges their spirits according to rules established by their friends living in the motherboard's psychic ecosystem, and exhales a modified stream of words.

In popular forms of media such as video games, therefore, words are being used as basic building blocks out of which ghosts of meaning come out, reveal themselves through the silhouette of the stage's veiling curtain, and greet their audiences.

(Keywords: #Word #Language #Linguistics #Communication #Informatics #Spirit #Ghost #Interface #Medium)

@@<hr>
<a12>
@@<h3><b>12. Phantom</b></h3>

A phantom is an inevitable byproduct of melancholy. It summons itself in the midst of one's illusion of hope, just to vanish all of a sudden and leave the observer dumbfounded in a cage of profound sorrow. It is the last summer night's dream, always missed but never grasped.

A phantom is usually a wicked reminder of one's foregone days which, like a late spring's cherry blossoms, had fallen down to the irreversible pit of time. They are unretrieved fragments of our missing past.

Today's media, including music videos, games, dramas, and the like, often hint the presence of such nostalgic illusion in the form of a magical enchantment, which erupts from a toybox of supernatural forces and rapidly dissolves back to thin air as soon as its charmful aura wears off.

A typical fairytale in today's world, for example, begins with a train of delightful gifts which soon get taken away at random moments in time (as though they were mere puffs of one's daydream). Images of fantastic creatures appear and disappear in irregular succession, never staying in fixed places.

In a way, therefore, phantoms reflect the inner anxiety of modern life in which people have lost their permanent identities and have become wanderers in the ocean of information superhighways. In this era of spiritual desolation, one has no choice but take refuge in glorious snapshots of one's past - those good old days back when things were simpler and had solid meanings.

(Keywords: #Fantasy #Fragmentation #Illusion #Magic #Nostalgia #Anxiety #Modernity #Urbanization #CherryBlossom)







:d:Living words allow us to communicate clearly and vividly. This article explains why we should avoid using "dead words".
:k:Language, Communication, Semantics, Words, Literature, Rhetoric, Writing
:l:2025-03-23

[Dead Words] March 23, 2025

<010>

When it comes to communicating with other people, we often face difficulties with regard to the effectiveness of the words we use.

For instance, when I say the word, "epistemology", what do you envision in your mind? If you are an academic person, you will probably be able to imagine its meaning in terms of academic papers you've read as well as their abstract narratives and cross-references.

The vast majority of other people, however, do not share the same level of knowledge which you may happen to have in your mind. Without a sufficient degree of background information in the context of philosophy, one simply cannot comprehend the meaning of the word "epistemology" without taking great pains investigating its origin.

The same goes with other abstract terminologies. Words such as "matrix", "vector", "derivative", or "predicate", can only be understood by those who have been acquainted with the study of mathematics. In the same vein, words such as "faith", "salvation", "sin", or "redemption", can only be accurately grasped by those who have at least studied the basic concepts in theology.

The problem is that no one knows everything, and that each person is only familiar with a tiny fraction of what the world knows as a whole. This sort of limitation renders it difficult for a musician to understand an accountant, a soldier to understand a poet, and a monk to understand a lawyer.

As a result, we are living in an inexplicably fragmented world, where everyone is speaking their own language. Cliques of like-minded experts lock themselves up in their impenetrable ivory towers, and refuse to communicate with the rest of the world.

What gave birth to this pandemic of mutual isolation? In my opinion, it all began with the sophistry of human mind and its tendency to use words that are dead rather than alive. What I mean by this will become clear in the example below.

If I say words such as "postmodernism", "teleology", or "substantialism", it will be hard for most readers to picture them in their minds. And the reason behind this is pretty straightforward. These academic terms are so abstract in nature, that they do not have tangible counterparts in our imagination. For example, we cannot imagine "postmodernism" as an object in space, with its own shape, color, sound, or smell. Since this word refers to a formless idea which is not directly associated with anything we can perceive, we are unable to sense it without taking circumventory measures (such as recalling a book in which we saw the word "postmodernism", or recalling the face of somebody who has spoken the word "postmodernism", and so on).

Therefore, abstract words such as the ones I just mentioned can be considered dead. They are "dead" in the sense that they do not have images which are vividly alive in our minds. They are lifeless because we cannot see their living bodies, hear their breath, or feel their beating hearts. They are skeletons of esoteric mental masturbation, buried deep inside the tombs of senseless intellectual pride.

On the other hand, if I say words such as "dragon", "fire", "sword", or "tree", it will be easy for anyone to instantly draw them on the surface of one's mental canvas. It is because these words are associated with living images; they are "alive" in our collective backwater of fantasy because, once we hear these words, they automatically summon their physical bodies within our field of vision.

Dead words exist for the sake of their own existence. They are ghosts of empty echoes, resonating in the voids of obscure references and endless wordplay. They came from nowhere, and are going nowhere.

Living words are different in the sense that they are fully exposed before our eyes. Once we hear them, we can instantly feel their presence without any explanation. This is the kind of personal warmth which we ought to leverage in order to touch the listener's heart.








:d:How to live longer, stay mentally sharp, and overcome addictions? In this article, I will tell you how a simple change of habit can help achieve all these goals easily.
:k:Intermittent Fasting, David Sinclair, Andrew Huberman, Longevity, Insulin, Diabetes, Health, Caffeine, Coffee, Black Tea, Caffeine Blues, Sugar Addiction, Carbohydrate Addiction
:l:2025-04-03

[Caffeine, Sugar, and Fasting] April 3, 2025

For many years, I had been a lover of both coffee and sweets. I used to start every morning with a fresh cup of coffee and a morsel of glazed pastry, which I grabbed and enjoyed as soon as I got off the bed. The point of this daily routine was to kick off each day with a fresh burst of energy, aided by both the power of caffeine and an instant rush of gluten-friendly carbohydrates.

This habit, unfortunately, had an obnoxious side effect.

For the first two or three hours after the breakfast, I indeed rejoiced in the sheer sense of stimulation which it graciously provided. Endowed with the morning's initial flare of mental clarity and the fiery blessings of the sugary meal, I was able to leverage this brief period of excitement for tasks which required extra sharpness in one's mind. The hours which followed this initial phase of enchantment, however, often baffled me.

By the time the glorious effect of the morning ritual began to wear off (i.e. about 9 or 10 AM), I invariably crashed into the state of mild depression and fatigue. It was not really a surprise; after the initial spike of spiritual brightness, one could definitely expect a follow-up of the opposing effect as a counterbalancing mechanism - a combination of brain fog, anxiety, and a feeling of inner discomfort and suffocation.

Of course, if I wanted to prolong the delightful aspects of my morning ritual, I could just shove another cup of coffee down my throat in order to borrow a few more hours of productivity from my future self. And, guess what? I sometimes did exactly that, and enjoyed its short-term merit. Each time I did, though, it accrued even more "fatigue debt" in my body, causing me to become even more depressed by the time I reached the post-lunch slump (about 2PM or 3PM). And, by the time I faced this moment of mid-day crisis, I could not find a way out of it because it was too late for me to take yet another cup of coffee (If I did, it would then interfere with my night's sleep).

The problem was that, by kicking off every morning with caffeine and sugar, I was constantly sacrificing the quality of my afternoon hours for the sake of bloating the first few hours of the morning with an extra boost. It was after quite a number of years that I finally began to realize the sheer inefficiency of it.

Here was the truth. The first one or two hours of the morning did not really demand any sort of external stimuli to sharpen my mind. The reason was that the very act of waking up in the morning automatically triggered my brain to be extra alert for the first couple of hours, due to the fact that the body's cortisol level peaked by the time I woke up (Source: {%a target="_blank" href="https://my.clevelandclinic.org/health/articles/22187-cortisol"%}"Cortisol"{%/a%} - by Cleveland Clinic). Drinking a cup of coffee during this period turned out to be wasteful, since the sense of mental clarity offered by cortisol alone was already powerful enough to let me stay productive during that time.

Hence, injecting caffeine into my brain right after waking up also proved itself to be a bad idea for another reason. Every time I woke up in the morning, adenosine (i.e. sleep inducer) still lingered in my brain, waiting to be attached to the brain's receptors and be dissolved. Having a cup of coffee interfered with its prompt removal, since the receptors to which caffeine molecules bound themselves happened to be the same ones as those to which adenosine molecules were supposed to bind. As a result, the presence of caffeine delayed the dismissal of adenosine during the first few hours of the morning, causing them to retaliate with an attack of drowsiness after the lunch (Source: {%a target="_blank" href="https://ai.hubermanlab.com/s/NKZpgdqs"%}"When should I drink coffee?"{%/a%} - by Andrew Huberman and Andy Galpin).

Another issue was that the initial surge of energy during the early morning, promoted by an enormous amount of caffeine as well as a huge dose of simple carbohydrate, induced my energy level to skyrocket and then quickly plunge into the swamp of depression afterwards (as a means of bringing the body back to its state of equilibrium). In my experience, a rapid rise was always followed by a rapid fall.

<011>

For these reasons, I began to realize that my feastful daily habit was unsustainable and prone to emotional instability. So I decided to abandon this age-long morning ritual (dedicated to summoning the gods of Starbucks Rewards Membership) and refactor the way I approached the problem of keeping myself productive all day long.

Here is the list of solutions I came up with.

1. First of all, I stopped drinking any caffeinated beverage during the first 1 to 2 hours in the morning. This helped the adenosine to be fully dissolved before they had any chance of being sustained by the presence of caffeine, thereby preventing them from striking me back with fatigue after lunch.

2. After this initial 1-2 hour time window, I promised myself to enjoy only a mild cup of black tea instead of a thickly brewed cup of dark roast coffee. Since a cup of black tea only contained about half as much caffeine as that of a cup of coffee (or even less), it helped me stimulate my brain in moderation. After all, too much excitement wasn't even beneficial to me; it deterred me from staying focused on one thing at a time. Also, consuming too much caffeine amplified its depressing side effect; reducing the amount helped me lower the intensity of the caffeine-induced slump and stay far more productive throughout the rest of the day.

3. What about sweets? Similar to caffeine, it definitely helped me fuel my brain during the first few hours of the morning. Just like caffeine, though, it revealed its own nasty downsides after a short period of time (such as depression, fatigue, anxiety, etc). Besides, I realized that health experts do not recommend eating anything right after waking up (Source: {%a target="_blank" href="https://ai.hubermanlab.com/s/A3RrNlJK"%}"What is huberman saying about eating in the morning"{%/a%} - by Andrew Hubermann). This eventually encouraged me to begin skipping breakfast altogether, subsequently letting me exercise a mild form of intermittent fasting (i.e. at least 16 consecutive hours (per day) of not eating anything, starting from the evening and continuing all the way up to the next day's lunch).

All these 3 new habits, when practiced in combination, produced wondrous results. To be honest, it took me quite a while to get used to this new lifestyle. The lack of both caffeine and sugar during the first part of the day made me depressed at first, since I had been mildly addicted to these two stimulating substances for many years. I had to spend about a week to get used to the absence of coffee, and about 3 or 4 weeks to be comfortable with the absence of food during the initial few hours of the day. Once I fully adapted my body to this new pattern of life, however, it drastically improved the quality of my mental health (as well as physical health. See: {%a target="_blank" href="https://www.nad.com/news/david-sinclair-explains-how-to-live-longer-by-changing-the-way-we-eat"%}"David Sinclair: How to Change Your Diet to Live Longer"{%/a%}).

<012>

To be honest, I would say that the aforementioned change of habit did not give me any sort of "superpower" or anything extraordinary (I am still who I am). Based on what I have been experiencing, however, I can confidently tell that the state of my mind has become significantly more composed than before, letting me think more clearly and objectively (not just during the morning, but throughout most of the day).

Furthermore, it has been providing me with additional benefits besides psychological well-being. Abstinence from both coffee and sugary snacks helped me save money, since both of them are considerably more expensive than their healthier equivalents (especially in my country). Meanwhile, intermittent fasting helped my body regulate its blood sugar level and other aspects of metabolism way more frictionlessly than before, thus freeing me from carbohydrate addiction as well as irregular mood swings.








:d:What makes true art? I will try to answer this question in the following article.
:k:Arts, Fine Arts, Classic, Aesthetics, Ethos, Pathos, Logos, Communication, Psychology, Propaganda, Commercial Art, Pop Culture, Pedagogy, Narrative, Rhetoric
:l:2025-04-10

[To Every Lonely Artist] April 10, 2025

@@<hr>
@@<h3><b>Preliminary</b></h3>

Crafting a piece of art which appeals to everybody is a challenge, primarily because the audience consists of innumerable individuals, each of whom possesses a unique set of knowledge and expectations. Making every one of them appreciate your art is nearly impossible.

It is also a mark of virtue, however, to strive to let your art be accessible to as many people as possible. I do not mean that you ought to be a conformist; indeed, you will lose your own identity as a creator if you choose to become somebody else just for the sake of gratifying the cheap taste of the crowd. However, it is just as unwise to brand yourself as a lonely genius who is a victim of one's own extraordinary talent, and use it as an excuse to cut yourself off from the rest of the world.

And if you are to entertain the notion that the audience must be sufficiently "educated" in order to comprehend your art, it will function as a proof that it is your own lack of aptitude which made such a prerequisite an absolute necessity.

The root of the problem with which you might be struggling, with regard to the compatibility of your "creative endeavor" with that of the expectations of the general public, could be broken down to three major elements of rhetoric which often conflict with one another. I will go over them below.

@@<hr>
@@<h3><b>1. Ethos</b></h3>

In most cases, people prefer to see and hear things which are already familiar to them. It is especially true in the context of mainstream media, where consumers are expected to be spoon-fed the sort of products they can easily identify and sympathize with.

People want to see things they have already seen, and hear things they have already heard, down here on Earth, right under the Sun. Originality is an unforgivable sin in the mass market of cheap pre-packaged customer satisfaction, and anything which deviates from the norm even by the slightest degree gets thrown into the trash can as the most despicable form of pompous nonsense. The very moment your audience faces something which does not instantly please their eyes in the most obvious manner, they will turn they heads away without a glimpse of forethought.

Your average audience is heartless, and every one of your words will be rejected and utterly ignored unless you present it under the spotlight of shallow idolatry.

Thus the most viable strategy from an economic point of view, in the end, is to aim for the lowest common denominator and make sure that every split second of the customer's attention span is dedicated to what's the most appealing to the senses - sex, violence, gluttony, gambling, and whatnot. And in this bloodless world of business and profit optimization, your moral eloquence has no place to stand.

@@<hr>
@@<h3><b>2. Pathos</b></h3>

To be fair, some forms of art go deeper than mere sensual pleasure, and they manage to elaborate themselves quite far as to plead with the viewer's emotions. Soap opera, heroic stories, and other breeds of romanticism fall into this category. They appeal to the poet's heart, and paint the picture of one's fairy tale castle with colorful narratives.

This kind of art relies its momentum on the provocative energy of justice, remorse, compassion, and other moral sentiments. In the end, however, will such an emotional drama surmount the accusation that it is nothing more than a mere piece of political propaganda, designed to exploit the hopeless who are desperate enough to sacrifice their hearts for a charismatic demagogue?

Emotions are indeed mighty means of furnishing your art with motives. By sticking to the suggestive power of personal feelings, it will surely be able to attract the eyes of those who are in need of spiritual reassurance. If such an objective is the sole philosophy upon which your art is founded, however, on what basis will you be able to assert that it evinces more flavors of elegance than the myriad self-help (aka "personal development") lessons which flood the marketplace of hope sellers?

@@<hr>
@@<h3><b>3. Logos</b></h3>

The aforementioned two methods of rhetoric, which rely heavily on either senses or emotions, may perhaps be too shallow and soulless in your world of art. As a result, you may be convinced that it is pure reason alone which has the force to suggest to the audience that your art is not just a mere piece of mindless entertainment, but something which carries some philosophical substance in it - something which is of intellectual and scholastic value.

This too, however, is vanity. People who are too busy to spend time outside of their worldly matters (e.g. business, friendship, family issues, jobs, etc) are hardly likely to pay attention to sophisticated ideas which constitute the pastime of pure intellects.

People who do possess enough time and talent to appreciate intellectual endeavors (e.g. scholars), on the other hand, will refuse to pay attention to your ideas either because their egos are too strong to let them acknowledge that somebody else might know something which they do not know. These elites are busy endorsing their own intellectual superiority, so they are unwilling to give any credit to their potential competitors.

And you know what? You, too, will not be able to free yourself from this evil if you do not keep your own ego in check.

@@<hr>
@@<h3><b>Conclusion</b></h3>

In the world of ethos, we stick to things which directly arouse our senses; it is the amusement park of superficial pleasure, devoid of philosophy. In the world of pathos, we struggle to win the hearts of people by means of emotional appeals; it is the bottomless pit of clumsy poetry in which nothing remains but the romance of momentary feelings. In the world of logos, we take refuge in the home of academic elites; it is the secret treehouse of "deep thinkers" - a select few who defend their secluded egos in their petty ivory tower of intellectual pride.

What, then, shall comprise a graceful work of art, which is endowed with its own philosophy yet still manages to grasp the souls of those who regard it? This is a tricky problem.

In my honest opinion, the best way to solve this is to endeavor to strike a fine balance among ethos, pathos, and logos.

Casual arcade games are sugarcoated with ethos, but they often lack both pathos and logos. Soap operas are rich in pathos, yet they are poor in logos. Minimalist arts and their intricate geometric patterns are filled with logos, but they fall short of ethos and pathos. It is only when we bring ethos, pathos, and logos together on a single line of narrative, that we will be able to formulate a universal kind of art whose voice resonates in everyone's ear. For at the focal point of their intersection, there is divinity.










:d:This article explains how to use linear algebra when designing and implementing a video game.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-05

[Linear Algebra for Game Development - Part 1] August 5, 2025

@@<hr>
@@<h3><b>Prerequisite</b></h3>

This article assumes that the reader already understands the basic concepts in linear algebra, such as matrix multiplication and vector arithmetic.

@@<hr>
@@<h3><b>Introduction</b></h3>

Let's say that you are trying to create a game, perhaps as an indie developer. What would you do to fulfill this objective?

There indeed are many viable approaches to such a problem. Some people may start by devising concept arts, while others may start by building their own fictional game worlds by means of writing and character design.

As someone with an engineering background, however, I am a bit biased in favor of system-based design methodology. While it is not the ultimate panacea for all aspects of game development, I do believe that it is a pretty sound means of handling innumerable complexities which may arise along the way.

A game comprises a variety of systems (e.g. UI system, physics system, graphics system, audio system, networking system, etc), yet I will solely focus on the gameplay system for now, for it is what makes up the conceptual backbone of a game.

@@<hr>
@@<h3><b>Inventory</b></h3>

First of all, let me suppose that you are designing a role-playing game (RPG). In this game, what you will need is the main character, as well as an inventory which lets the player store a number of items in it and carry them around. What is shown below is an inventory which contains 3 items - a frog, a diamond, and an apple.

<b001>

@@<hr>
@@<h3><b>Selecting an Item</b></h3>

Let us now use our common sense, instead of delving into endless rigmaroles of wild imagination. Here is the question of foremost significance: "What is the most essential functionality that we need to be able to use this inventory?"

There are more than one possible answers, but we can all agree on the fact that the player must at least be able to "select" an item in the inventory instead of just looking at it. The reason is straightforward; if you are unable to select an item in your own inventory, you won't be able to do anything with it.

Let's say that the player wants to select the first item in the inventory (i.e. frog). What shall we do to make that happen?

<b002>

Here is a solution which may sound unpleasantly esoteric (for those who are not familiar with linear algebra), but nevertheless reveals itself to be quite elegant when it comes to computation. Imagine that the inventory we just saw is a column vector (i.e. a vertical list of items) which consists of 3 rows and 1 column.

The way you select the inventory's first item, then, is to multiply this column vector by a row vector (i.e. a horizontal list of items) which has 1 in its first entry and 0 elsewhere.

<b003>

The underlying logic is not hard to grasp. Multiplying the aforementioned row vector and a column vector has the same effect as taking 1 copy of the frog, 0 copy of the diamond, 0 copy of the apple, and then simply adding them up. The result is just 1 copy of the frog, which is exactly the same thing as the original frog which has been sitting in the inventory.

<b004>

Here is another question. What shall we do, if we want to select the second item (i.e. diamond)?

<b005>

The answer is pretty much the same as the previous one, except that now the row vector contains its "1" in the second entry instead of the first entry. This will select the second item in the inventory instead of the first, thereby returning the diamond.

<b006>

@@<hr>
@@<h3><b>Selecting Multiple Items</b></h3>

What if the player wants to select multiple items at once? Such a scenario will be necessary if the gameplay involves special skills which can be activated only when two or more items are combined. A wizard, for example, will need to grab both a "mana" item and a "fire" item at the same time to be able to cast a "fire spell" (as opposed to a "null spell"), and so on.

Let me suppose that we are trying to select both the frog and the diamond in the inventory. What should we do to make this happen?

<b007>

The best way to answer this kind of question, is to look back at the previous answers and try to find out a way to combine them to be able to solve a bigger problem.

It has been shown that selecting the first item (frog) can be achieved by multiplying the inventory by the row vector: [1 0 0]. Similarly, it has also been shown that selecting the second item (diamond) can be achieved by multiplying the inventory by the row vector: [0 1 0].

In linear algebra, it is also possible to execute both of these two actions in parallel by stacking the aforementioned row vectors (i.e. [1 0 0] and [0 1 0]) together to form a 2x3 matrix, and then simply multiplying the inventory by that matrix.

<b008>

This has the effect of carrying out two different multiplications at once - (1) multiplication by the first row vector, and (2) multiplication by the second row vector.

The first multiplication, carried out by the first row of the matrix, gives us the first inventory item (frog). The second multiplication, carried out by the second row of the matrix, gives us the second inventory item (diamond).

We can extend this parallel operation by attaching the third row to the matrix which selects the third inventory item (i.e. [0 0 1]). The resulting 3x3 matrix will let us select ALL three items in the inventory, which is the same thing as selecting the entire inventory as a whole, as it is, without excluding anything.

<b009>

This is why this 3x3 matrix is called an "identity matrix". The resulting selection is identical to the original inventory.

@@<hr>
@@<h3><b>Rearranging Things</b></h3>

So far, we have only been selecting items in the inventory without doing anything with them. In order to add some interactivity to the game, we better let the player apply some changes to the inventory, instead of just looking at a portion of it.

Gameplay is made up of actions, each of which could be triggered either by the player or some other in-game agent. The simplest action we can think of is the act of moving something from one place to another.

Here is a question. Assume that I wish to swap the positions of the frog and diamond in the inventory. What shall I do?

<b010>

Let's revisit our previous observations. Do you remember, that it is possible to select the second item (diamond) by multiplying a row vector, whose second entry is 1 and everything else is 0?

<b006>

Likewise, you may recall that it is possible to select the first item (frog) by multiplying a row vector, whose first entry is 1 and everything else is 0.

<b003>

If we first select the second item (diamond), then select the first item (frog), and then put these two operations in parallel, what do we get?

<b011>

In this case, we are still "selecting" a frog and a diamond, but in the opposite order. In the original inventory, the frog was first and the diamond was second. In our new selection, however, the diamond is first and the frog is second.

So, we just succeeded in reversing the order between the frog and the diamond, but a problem still remains. The apple in the original inventory is missing here!

When swapping two items in the inventory, what we really want is not a subset of the inventory, but the full inventory in which the desired change has been applied. Therefore, we ought to reconstruct the whole inventory by selecting EVERY item.

This can be done by making sure to select the last item (apple) as well, besides the frog and diamond.

<b012>

@@<hr>
@@<h3><b>Movement</b></h3>

This kind of reasoning also applies to the problem of making simple movements. If we imagine that the frog is the only item in the inventory and the rest of the slots are empty, the matrix I have just shown can be used to "move" the frog from the first slot to the second slot, since moving something from one place to another is the same thing as swapping the origin with the destination.

<b013>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-09

[Linear Algebra for Game Development - Part 2] August 9, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 2 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Successive Movements</b></h3>

In the last article, I demonstrated the way in which we could move an item from one location in the inventory to another. Moving the frog from the first entry to the second entry, for example, could be done by swapping the first entry with the second entry.

<b013>

If I apply the exact same type of movement once again, however, the frog will go back to its original location.

<b014>

The reason behind this is that swapping the same pair of entries twice has the same effect as keeping everything the same as before.

<b015>

In order to prevent the frog from going back to where it was, we need to make sure to apply a different kind of motion to the frog once it reaches the second entry; that is, we will have to swap the second entry with the third entry if our goal is to push the frog to the third entry.

<b016>

A sequence of movements, then, can be carried out by a sequence of swaps. First we swap the 1st with the 2nd, and then we swap the 2nd with the 3rd, and so forth. This will successively move the 1st to the 2nd, the 2nd to the 3rd, etc. This can be done by successive matrix multiplications, like the ones illustrated below.

<b017>

For the sake of convenience, it is also desirable to combine these two matrix multiplications by multiplying them together, which will then produce another matrix. This resulting matrix, when applied to our inventory of items, will perform two successive swaps at once.

<b018>

This is an example of what we would refer to as a "transaction". When we multiply the inventory by this composite matrix, it always makes sure that two events must happen at the same time - (1) A swap between the first and second items, and (2) A swap between the second and third items.

<b019>

At this point, you may have realized the overall effect of performing two successive swaps in our inventory of three items. What it does is, it moves (shifts) every item by one entry. When an item gets pushed off the edge, it cycles back to the other end of the inventory. This is a circular shift.

<b020>

@@<hr>
@@<h3><b>How to Resize the Inventory</b></h3>

So far, we have only been looking at an inventory of three items. In most video games, however, the player will probably wish to hold more than three items in one's inventory. Three is just not enough!

On the other hand, though, it also makes sense to initially only provide a newbie with a small inventory, and then let him/her "upgrade" its size as the game's narrative unfolds. One reason is that it lets the player feel a sense of progression while playing. Another reason is that it gives the developer an opportunity to make money by forcing the player to make an in-app purchase in exchange for adding more slots to the inventory.

Here is an example scenario which demonstrates the concept. Suppose that you are developing a construction simulator, in which the player needs to grab as many bricks as possible and carry them to the construction site to make a brick wall. The player is initially only able to carry 3 bricks at a time because his/her bag is too tiny. After an in-app purchase of, say, 5 dollars or so, the size of the bag doubles up which will let the player carry up to 6 bricks instead. Will the player pay 5 dollars to afford it? The answer will be "yes" if the game proves itself to be sufficiently engaging.

But anyways, we can all agree that being able to increment the size of the player's inventory is a pretty good feature to have. So, why not implement it now, and investigate more of its use cases later on?

Let us go back to the beginning, and take a look at our initial inventory which could only hold up to 3 items.

<b001>

For a newbie player, this is probably more than enough. After all, we cannot expect a beginner to possess the ability to handle more than 3 items at once (We will be lucky to have the player learn how to use the inventory in the first place).

Suppose that, at some point during the gameplay, the player needs to increase the size of the inventory to 4 slots, so as to be able to carry up to 4 items instead of 3.

<b021>

What shall we do to achieve this goal? Here is a little reminder. Do you recall that, by taking a product between a row vector and the inventory, we are able to "select" one of the entries within the inventory?

<b003>

If the row vector is [1 0 0], we will get the first item. If the row vector is [0 1 0], we will get the second item. And if the row vector is [0 0 1], we will get the third item.

We should also remember that putting these row vectors together as a matrix of multiple rows will allow us to select multiple items simultaneously. The matrix shown below, for instance, lets us select the entire inventory.

<b009>

Note that it is also possible to select nothing at all by means of a row vector whose numbers are all 0. Such a vector, when applied to the inventory, returns an empty slot.

<b022>

If we attach this "empty selection" to the list of all possible item selections, what do we get?

<b023>

The result is a list of four selections instead of three. The first three selections are the three items in the original inventory (i.e. frog, diamond, and apple). The fourth selection is an extra slot which is now attached to the end of the inventory. This extra slot is empty because we selected "nothing" from the original inventory.

@@<hr>
@@<h3><b>Dimension Shift</b></h3>

One interesting thing we can observe here, is that the matrix we just used to change the size of the inventory from 3 to 4 is of size 4x3 (i.e. 4 rows and 3 columns). Do you see the pattern here?

<b024>

The number of columns represents the size of the original inventory. The inventory could hold up to 3 items, so each selection required us to specify 3 distinct numbers to be able to select each one of its slots.

The number of rows, on the other hand, represents the size of the resulting inventory. Since we made 4 selections by multiplying 4 row vectors in parallel, we ended up producing a list of 4 slots.

A 4x3 matrix, therefore, can be imagined as some kind of "expander" which converts a list of 3 items into a list of 4 items.

Similarly, it should also make sense that a 2x3 matrix is some kind of "compressor" which converts a list of 3 items into a list of 2 items. In the example below, we are doing this by simply selecting a subset of the original inventory (i.e. by only selecting the first two items and discarding the last).

<b025>

@@<hr>
@@<h3><b>List Operations</b></h3>

At this point, you might have realized (especially if you are a programmer) that the so-called "inventory" in our examples may as well be regarded as what is commonly known as a "list" in computer science, since it is just a sequence of items.

Our inventory is just a list, which is one of the most pivotal data structures when it comes to computational reasoning. What's good about linear algebra is that it allows us to express each of the core list operations as a simple matrix multiplication.

<b026>








:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-13

[Linear Algebra for Game Development - Part 3] August 13, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 3 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>The World and the Inventory</b></h3>

So far, I have been talking about ways of representing the player's inventory, accessing its items, changing their positions, and so on. However, I haven't yet tried "using" any of those items for gameplay purposes.

If I were playing a video game and found out that my main character was starving, I would expect myself to be able to grab a piece of bread from the character's inventory and feed it to replenish its stamina. If the bread cannot be used for such a purpose, what's the point of having it in the inventory in the first place?

This means that we need some way of allowing the player's inventory and the game world to interact with each other. That is, we ought to be able to pull an item out of the inventory and apply it to one of the characters in the world, or to pick up an item in the world and put it in the inventory, and so forth.

<b027>

It seems to suggest, then, that it is necessary for us to model our gameplay in terms of two separate spaces - the world and the inventory. This kind of conclusion, however, does not solve the problem of implementing their mutual interactions within the context of linear algebra.

I have previously illustrated that it is nice to represent the player's inventory as a column vector, and any modification to the inventory as a matrix multiplication. In the same vein, we might also entertain the notion that we could represent the gameplay world as a column vector as well, where each element of the vector corresponds to a position in physical space.

<b028>

This still does not tell us how we will ever manage to describe interactions between the two domains, though. In order for an interaction to take place, for instance, we must make sure that it is possible to transfer things (e.g. items) from the world to the inventory and vice versa. How do we model such events in terms of vectors and matrices?

The answer is, we can't (Or, even if we can, it is way too complicated). Fortunately, there is a clean way to bypass this difficulty. Why not just assume that both the world and the inventory are parts of the same space, represented by a single column vector? After all, there is no compelling reason why we are supposed to consider these two as separate entities.

<b029>

Everything is part of the game. The world is part of the game, and the inventory is part of the game. Therefore, it is not too absurd for us to imagine the entire gameplay universe as one monolithic sequence of items (i.e. a single column vector), partition it into sections, and give each of them a distinct role.

@@<hr>
@@<h3><b>Joining the Two Realms</b></h3>

Okay, so here is the idea. Let us assume that the game is made up of a list of 6 entries, each of which may either indicate a position in the game world or an item in the inventory. The upper half of the list is the world, and the lower half of the list is the inventory.

We can select the whole world by selecting the top 3 entries of the list.

<b030>

Alternatively, we may select the whole inventory by selecting the bottom 3 entries of the list.

<b031>

What if we want to select the apple in the player's inventory? Oh, it is not hard to guess at all. Since the inventory is the last 3 items of the list and the apple is the last of them, we can expect to obtain the apple when we select the last item of the whole list.

<b032>

But of course, what we really need here is interaction. We are not playing a game if we are not interacting. And just like I have mentioned before, the way we achieve it is by being able to transfer things between the world and the inventory.

First, though, let us begin with the most basic choice that the player should be able to make during the game. It is when the player decides to stay idle, leading to absolutely no change in the game's environment during the current time step. Whenever this happens, everything must stay the same. And the way we do this is by selecting everything in the list, including both the world and the inventory.

<b033>

Again, what we are seeing here is an identity matrix; it lets us create an identical copy of the original list, by selecting everything in it in the same order as before (i.e. by selecting the 1st item, then the 2nd item, then the 3rd item, and so on).

Imagine, now, that the player wants to eat an apple in the inventory, which is located at the 6th entry of the list. The player's current position is the 2nd entry, so let us move the apple right in front of him (which corresponds to the 3rd entry of the list), so as to let him have direct access to it. We can carry out this action by selecting everything in the list, but with the 3rd and 6th entries swapped.

<b034>

Once he grabs the apple in front of him and eats it, it must disappear. This can be carried out by simply NOT selecting the apple's location (i.e. 3rd entry) while selecting everything else.

<b035>

All right. What we just saw is a series of steps which allowed us to pull the apple out of the inventory, put it right in front of the player, and then delete it once it is eaten.

@@<hr>
@@<h3><b>Exchange</b></h3>

This, however, does not explain what happens to the player himself when he eats the apple. An apple should not simply disappear when it is eaten without affecting anything else in the world.

What we need is an exchange. When the player eats an apple, he expects to gain energy from it in exchange for the act of sacrificing one of his items. Otherwise, it would mean that he just dumped an item for nothing.

<b036>

Such a degree of nuance, though, requires us to represent the game in terms of not just items, but also numerical properties. And such properties should exist as part of things (i.e. objects) which are populating the game world.

<b037>

The player, for instance, may have one or more numbers associated with him such as his energy (which he consumes whenever he makes a move - aka "action points"), his health (which must be kept above 0 to prevent him from dying), and so forth.

It will be nice if we can treat such details in a highly scalable manner, so as to be able to handle them without complicating things too much. And in order to achieve this kind of goal, we must strive to model everything in terms of the constructs of linear algebra (e.g. vectors and matrices).

Here is a recap of how I have been representing the gameplay universe. From a computational point of view, our game comprises a list of entries, each of which is capable of being occupied by a single object. Each entry indicates either a position in the world, or a "slot" in the player's inventory.

<b038>

As you may have already realized, this system is quite limited in the sense that it only allows each entry to have a single object in it, with no room for additional details. When an inventory slot is occupied by an apple, for instance, all we can ever know is that there is an apple. Nothing tells us how ripe it is, whether it has been washed, or whether it has been partially eaten. All we've got is just an atomic entity called "apple".

For more nuanced description of what is going on inside the game, we need to extend our column vector into some kind of "data table" - that is, a spreadsheet-like table which consists of both rows and columns.

<b039>

Each row corresponds to a location, and each column corresponds to a property (such as "energy", "health", etc) that a location can have.








:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-17

[Linear Algebra for Game Development - Part 4] August 17, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 4 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Compound Data</b></h3>

In the previous section, I introduced the idea of modeling our gameplay universe not as a single list (i.e. column vector) of items, but as a data table which consists of rows and columns. Each row refers to a location, and each column refers to a property.

<b039>

To clarify the meaning of what I just said, I will come up with a couple of examples. First of all, if we select the second row and first column of the table shown above and take a look at their intersection, what do we see?

<b040>

What we are seeing here is the player. The content of this specific data cell (i.e. human figure) tells us that the identity (ID) of the player is associated with position 2 (i.e. that the player's current location is position 2).

Here is another example. If we again select the table's second row, but this time choose to select the second column instead of the first column, what do we see in their intersection?

<b041>

Here, we are seeing a number instead of the player himself. The column's label suggests that it is the energy associated with position 2. Whose energy? The player's energy! It is because this number shares the same location with the player.

The so-called "player", in the context of this data table, can be considered as an object with its own internal properties. In our example, the player is an object with its own ID (which is a human figure) and the amount of energy he has (which is 3). And since both of these properties belong to the same row which corresponds to position 2, we can say that the player is located at position 2.

<b042>

@@<hr>
@@<h3><b>The World as a Table</b></h3>

In general, it is convenient to imagine each row of the data table as a distinct "thing" which exists within the game world, and its list of column values as the properties describing what it is.

<b043>

This implies that each intsection (cross) between a row and a column describes an association between a thing and its related property.

<b044>

The size of the data table tells us a lot about the scale and complexity of the world. The number of rows, for example, is the maximum number of things which can populate the game world (It is the world's "volume"). The number of columns, on the other hand, indicates the maximum number of properties that each thing is able to possess.

<b045>

We can select each "thing" by selecting each row of the table. The image below, for instance, shows how to select the player as a whole, including all of his associated properties.

<b046>

And of course, simultaneously selecting all the rows lets us obtain an identical copy of the entire game world.

<b047>

@@<hr>
@@<h3><b>Transaction</b></h3>

This is all good so far, but what we really need is gameplay. Previously, I had mentioned the difficulty of carrying out an exchange between the act of consuming one of the items in the inventory (e.g. apple) and the advantage of doing so.

When we eat something, we expect to acquire energy (calories) from it. Likewise, the player should expect to gain energy from the apple when he eats it.

How to model this piece of logic as a gameplay mechanic? First, let us suppose that the amount of energy stored within the player is 3 and that the amount of energy stored within the apple is 1 (just as illustrated in the data tables above). When the player eats the apple, we can obviously expect the apple to disappear. At the same time, though, we should also expect the player to "absorb" the apple's energy by adding it to his own energy storage (That is, add 1 to 3, which results in the total energy of 4).

<b048>

In the context of rows and columns, this kind of exchange can be modeled as a set of changes in the data cells. The disappearance of the apple is equivalent to the deletion of the data in its row, and the process of transferring the apple's energy to the player is equivalent to the addition of the apple's energy to the player's energy.

<b049>

How to achieve these goals using the mathematical operations we've been looking at so far (e.g. matrix multiplications, etc)? A rather straightforward attempt would be to directly translate the aforementioned goals into their corresponding row operations.

First, let us add the 6th row to the 2nd row because the 6th row is where the apple's energy is located and the 2nd row is where the player's energy is located.

Meanwhile, let us also erase the 6th row because that's where the apple and all of its properties are located. We ought to wipe the apple out of its existence when the player eats it.

<b050>

Both of these actions can be executed simultaneously, by means of a single matrix multiplication. And for the most part, it seems to be yielding a pretty sound result. The apple got erased, and the player absorbed the apple's energy.

Unfortunately, there is one fishy thing going on here. Do you see what just happened to the player himself (i.e. the human figure), in the 2nd row and 1st column?

<b051>

Adding the 6th row to the 2nd row added up not just the energy levels, but also the identities (IDs) of the two objects - the player and the apple. As a result, what we are now seeing in the 2nd row is no longer the original player, but a strange hybrid between a human and an apple.

@@<hr>
@@<h3><b>Separating out the Columns</b></h3>

Here is what we need to do instead. Rather than adding the entire row (which resulted in adding not just the energy numbers but also the IDs), we want only a particular data cell within the row to be added (i.e. the energy). And in order to do this, we must split the table by columns.

<b052>

This will produce two subtables - one which only contains the IDs, and the other one which only contains the energy numbers.

In our subtable of IDs, there is only one thing which needs to happen. We want the apple to disappear, and that's all.

<b053>

In our subtable of energy numbers, on the other hand, there are two things which need to happen. First, the number in the 6th row must be added to the number in the 2nd row. Furthermore, the number in the 6th row must be erased because the owner of the energy (i.e. the apple) is now gone.

<b054>

Once all these changes have taken place, we can then recombine these two subtables to yield the final result, in which the player has eaten the apple and digested it successfully without accidentally transforming himself into an apple-flavored mutant.

<b055>

Okay, this makes sense. But we still have to know how to split the two columns (i.e. IDs and energy numbers) from each other and then merge them afterwards. We haven't seen these kinds of operations before, so I will try to explain how they can be implemented.

So far, we have been playing with individual rows, but not with individual columns. We have only been able to treat each row as an atomic (indivisible) entity, rather than something which could be broken down to smaller pieces.

This limitation, however, is due to the fact that we have only been placing our table on the right hand side of the matrix multiplication. With this insight in mind, I will come up with a solution to the aforementioned problem in the next article.









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-21

[Linear Algebra for Game Development - Part 5] August 21, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 5 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Column Operations</b></h3>

We have seen so far that it is possible to select individual rows in our data table, swap them with each other, add one of the rows to another, and so on. But what if we want to be able to manipulate not just rows, but also columns in a like manner?

In the previous article, I have shown that it is necessary for us to split the table by its columns and then recombine them later on, so as to be able to modify each of the properties (i.e. column values) without unintentionally tampering with the others.

Let me revisit the example we have been looking at. In order to handle the two properties (i.e. ID and energy) separately, we must first separate out the table's two columns.

<b052>

Then, after modifying them individually (by means of matrix multiplication), we must be able to rejoin these two columns back to the original form.

<b055>

Let's see how we can manage the splitting part. First of all, I would like to tell you that the act of splitting is basically the same thing as executing the following two tasks:

(1) Select the first column of the table.
(2) Select the second column of the table.

<b056>

One noteworthy point is that these two must be carried out separately. Let me begin with the first one - the process of selecting the first column.

How shall we manage to select only the first column of the table, leaving out the second column? The answer is that we can't, as long as we choose to multiply a matrix on the left side of the data table.

If we choose to multiply a matrix on the right side of the data table, however, it will let us select the individual columns of the table instead of rows. Here is how it works.

<b057>

What you are seeing here is an act of selecting a column. This example selects the first column of the table in particular, since we are multiplying it by a selector (i.e. a column vector) whose first entry is 1. If you carry out the multiplication, you will realize that it does indeed result in the first column of the original table and ignores the second column.

In contrast, we can select the second column of the table by setting the second entry of the selector to 1.

<b058>

As a side note, I would also like to mention that it is also possible to select multiple columns at once by putting multiple selectors in one place.

<b059>

@@<hr>
@@<h3><b>Row Selectors and Column Selectors</b></h3>

This leads us to the realization that there are two different ways of selecting a portion of our table - selection by rows and selection by columns.

The core idea is that, by multiplying the table by some kind of "selector", you can select either a row or column of that table. If this selector is a row of numbers which is placed on the left side of the table, it will return a row.

<b060>

If you put a multitude of such selectors in parallel, you will be able to select multiple rows at once.

<b061>

On the other hand, if the selector happens to be a column of numbers which is placed on the right side of the table, it will return one of the columns of the table instead of a row.

<b062>

And, just like you can select multiple rows by putting multiple row selectors in one place, you can select multiple columns by putting multiple column selectors in one place.

<b063>

What if you decide to select both a row AND a column at the same time? The way you do this is straightforward; you just put your row selector on the left side of the table, and your column selector on the right side of the table.

<b064>

Once you do the calculation, you will soon discover that the result of this two-step multiplication is the intersection between the selected row and the selected column.

@@<hr>
@@<h3><b>Modification of both Rows and Columns</b></h3>

In general, though, the range of things we can do by means of matrix multiplication is a lot broader than what I just demonstrated here. Besides selection, as you already know, we are also able to swap the rows (columns), add them up, etc.

Rather than just row selectors, for instance, we may as well construct a generic "row-manipulating matrix" which, when placed on the left side of our data table, will fiddle with its rows.

Likewise, rather than just column selectors, we may as well come up with a generic "column-manipulating matrix" which, when placed on the right side of our data table, will fiddle with its columns.

<b065>

@@<hr>
@@<h3><b>Two-Step Operations</b></h3>

Based upon these two major building blocks, we are now able to define all sorts of sophisticated game mechanics using matrix multiplication. Since we have the power to manipulate not just rows but also columns of our data table, separately managing each individual property (e.g. ID, energy, etc) will be a piece of cake.

The picture below demonstrates how we can destroy the apple by simply erasing it from the player's inventory AND discarding the energy-column of the table at the same time. All we have to do is carry out the former process on the left side of the table (because it deals with rows), while also making sure to carry out the latter process on the right side of the table (because it deals with columns).

<b066>

Meanwhile, we can handle the concept of energy exchange by transferring the apple's energy to the player AND discarding the ID-column of the table at the same time.

<b067>

These two actions will give us the two halves of our desired result. In the first half of the result (i.e. first column), we see that the apple has been successfully removed from the inventory. In the second half of the result (i.e. second column), we see that the apple's energy has been successfully transferred to the player. The only remaining task is to join them back.

<b055>

How to do this? In order to accomplish the goal of converting two single-column tables into one double-column table, we must first realize that we are trying to apply some kind of "size change" to the tables we are dealing with. Do you remember that it is possible to add extra rows (i.e. items) to the inventory by making more row-selections than the ones which are currently available?

<b023>

In a similar manner, we are also able to add extra columns to our data table by making more column-selections than the ones which are currently available. For example, if we choose to make an extra "empty selection" on the right side of the ID-column, a new empty column will appear on its right side.

<b068>

Likewise, if we choose to make an extra "empty selection" on the left side of the energy-column, a new empty column will appear on its left side.

<b069>

We are one more step closer to the final result. Now that the sizes of these two tables are both identical to that of the original data table (which consists of 6 rows and 2 columns), all we need to do, then, is simply add them up to finish our mission.

<b070>

The result is exactly what we expected. The apple is now gone, and the player has successfully absorbed the apple's energy.

The diagram shown below depicts the full process of making the player eat the apple and acquire energy from it. As you can see, it first splits the data table into two columns, manipulates them separately, and then recombines them to recover the table's original format.

<b071>










:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-25

[Linear Algebra for Game Development - Part 6] August 25, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 6 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>2D Movements</b></h3>

It has clearly been proven that, by applying two different matrix multiplications to our data table (one on the left, and the other one on the right), we are able to manipulate both rows and columns.

One of the most basic things we can do in our game world is to move items from place to place. And the two-dimensional nature of matrices suggests us that it is possible to make 2D movements by playing with rows and columns.

To demonstrate this point, I will come up with a slightly modified version of the player's inventory. What you are seeing below is an inventory of items which is not a list, but a 2x2 grid of items.

<b072>

Here is a quiz. What will you do if you are asked to move the frog to the right?

<b073>

As you can probably tell, simply swapping the two columns of the inventory is not going to work. It is because we do not want to modify the bottom row; all we need is flip the two items on the top row - not the ones on the bottom.

In order to solve this problem, then, we must handle the two rows separately. And for this purpose, we need to first split the rows and convert them into two separate tables. This can be done by making two row selections in parallel - one which selects the first row, and the other one which selects the second row.

<b074>

We don't need to do anything with the second row because the diamond and apple are supposed to stay where they are. The only row we need to modify is the first row, where the frog is located. In this row, all we have to do is just swap the two columns, which will effectively swap the frog with the empty slot on its right hand side.

<b075>

This basically moves the frog to the right. The only remaining step is to recombine the two rows back to the single 2x2 grid format, so as to recover the original dimensions of the inventory. To do that, we first need to attach an extra row to each of these two isolated rows for the purpose of synchronizing their sizes with that of the final result (i.e. 2x2).

<b075a>

Then, we just need to add these two 2x2 results together to obtain the final result, which is exactly what we would expect after moving the frog from the left to the right.

<b076>

Here is another quiz. What will you do if you are asked to exchange the positions of the frog and the apple?

<b077>

This one is trickier to solve. Since it involves diagonal movements (e.g. the frog needs to move not just rightward but also downward), we cannot simply split this 2x2 inventory either by two rows or by two columns. The former will let us move the frog to the right, but not to the bottom. The latter will let us move the apple to the top, but not to the left.

So, how shall we resolve this set of conflicting goals? While there might be more efficient ways, one method which is easy to understand is to break this problem down to a series of smaller problems.

When we think of a swap between the frog and the apple as a sequence of simple movements (each of which is either horizontal or vertical but not both), it leads us to imagine that such a diagonal swap can be achieved by first swapping the frog with the empty slot on its right, swapping the frog with the apple, and then finally swapping the apple with the empty slot on its left.

<b078>

Each of these 3 simple movements, then, can be further broken down into a list of matrix operations. For a horizontal swap, we first split the inventory into two rows, reverse one of them, and then recombine them. For a vertical swap, we first split the inventory into two columns, reverse one of them, and then recombine them.

At this point, however, you may be thinking that I am overcomplicating things. And yes, it indeed is the case. The number of calculations needed for carrying out even a single diagonal swap between a pair of items is way too large, and it makes us seriously question the sanity of how we have hitherto been representing positions/movements.

@@<hr>
@@<h3><b>Position as a Numerical Property</b></h3>

The root of the problem is that we have been equating the coordinates of matrix entries with those of physical positions in the inventory. We have been accustomed to say that the apple is on the right side of the diamond, for example, if the apple's entry is located on the right side of the diamond's entry in the matrix.

<b079>

While is kind of representation feels highly intuitive and easy to understand, it challenges us with loads of technical difficulties when it comes to making any modifications to it. Since it forces us to model every change in location as an exchange of rows/columns in the matrix, we have no choice but push ourselves through a bunch of cumbersome processes just to accomplish things that are so trivial.

At this point, therefore, we need to think of a better solution. Here is my thought.

What if we just start treating each item's position as a numerical property, written as one of the elements in the matrix (i.e. data table)?

<b080>

Here, I am explicitly stating the positions of the items (i.e. XY coordinates) inside a whole separate column, while listing each of the items as a row in the data table. This way, we no longer have to match the size of our data table with that of the actual inventory. In this example, the inventory itself is still 2x2 in size (as you can tell from the fact that both the X and Y coordinates range from 1 to 2), but our data table doesn't have to be of that size.

What makes this approach so elegant is that it lets us no longer treat positions in a special manner.

Take a look at the table below; it has an extra column called "energy", meaning that we are now allowing each item in the inventory to have its own energy level associated with it.

<b081>

As you can clearly see, there is no difference from "position" and "energy" from a technical point of view. They are both columns in the data table, filled with numerical values. If we want to change the positions of the items, we no longer have to modify the structure of the table itself; we just need to fiddle with their "position" property values, which are all listed in the second column.

And since they are all part of the same column, modifying their values is straightforward even in cases of diagonal movements.

Let us go back to the previous problem of swapping the frog and the apple.

<b077>

This problem was hard to solve because we were trying to directly modify the items' 2x2 arrangement, which inevitably involved changes both in the table's rows and columns.

In our new, alternative representation of the inventory (shown below), on the other hand, the problem turns out to be far simpler.

<b081>

Since all the position values are listed in the second column of the table here, we know that we only need to make changes to this particular column only. This means that we can safely discard all the other columns by splitting them apart.

<b082>

As you have seen before, the way we extract (split) each column from the data table is by selecting each of them individually using matrix multiplication.

<b083>

Once the 3 columns are splitted apart, we only need to modify the content of the second column (i.e. the column representing position values). Since we are swapping the frog's position with the apple's position, all we have to do is swap the column's 1st row with the 4th row.

<b084>

We can then proceed to augment the sizes of the 3 separated columns to match them up with that of the original data table (i.e. 4x3). For example, the image below shows how we can append two empty columns to our second column in order to recover its place in the data table.

<b085>

Then, we can simply add up the results of such augmentations to acquire the final state, in which the positions of the frog and apple are swapped.

<b086>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-08-29

[Linear Algebra for Game Development - Part 7] August 29, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 7 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Advantages of Representing Positions Numerically</b></h3>

In the previous article, I explained how each item's position in the inventory can be represented not by its location in the data table (i.e. row and column), but by a numerical property associated with it. And for such a purpose, I introduced an additional column in the data table called "position", which is filled with the items' positions.

<b080>

The biggest advantage of handling positions this way is that, since all the position values are aligned in a single column, we can manipulate the items' locations simply by modifying this particular column alone, without modifying any of the other columns.

In addition, there are other major benefits offered by this solution. First of all, since the data elements in the "position" column are just numerical values (i.e. XY coordinates), the range of positions that each item can have is unbounded. That is, nothing stops us from imagining our inventory of items as an infinitely wide 2D plane, since any combinatiion of X and Y values can be used to represent an item's position in the inventory.

<b087>

Another benefit is that, since the location of each item is no longer exclusively bound to an entry in the data table, we are now able to overlap an item on top of another by setting their positions to the same value.

<b088>

And the way we do this is simple. We first separate out the column of position values (just like we've done before), and set the position of one of the items to be identical to that of the other item.

<b089>

Furthermore, since there is no rule which says that the XY coordinates must be integers, we are free to locate our items at any non-discrete points in 2D space. For example, it is completely fine to put our frog somewhere in between a pair of adjacent grid cells.

<b090>

@@<hr>
@@<h3><b>Shifting a Position</b></h3>

Making this kind of movement, however, is a bit tricky. In the example shown here, we cannot simply swap the position of the frog with that of the empty grid cell, since it will put the frog right at the center of that cell.

Suppose we are trying to push the frog to the right by just a half of a grid cell (i.e. 0.5). In this scenario, what we really want is to add the value of 0.5 to the frog's X-coordinate, which is equivalent to the addition of (0.5,0) to the position value.

<b091>

How to let this happen, in the context of linear algebra? For sure, you might have already guessed a quick solution which technically works. After splitting up the data table's columns, we can just add a column of "offset values" to the column of positions to be able to see the desired consequence.

<b092>

This works. However, it is a bit too cumbersome from a computational perspective. I would insist that there must be a better way, and indeed there is! Here, I will present you with an alternative method which is far more elegant.

The first thing we will need is to add an extra row to our data table, whose "position" value is set to (1,0). All the other column values in this row are set to zero (empty).

<b093>

We can then add 0.5 to the X-coordinate of our frog's position by means of not a brute-force addition of two columns, but a matrix multiplication. You can see how it works in the picture shown below. The matrix on the left side takes a half (0.5) of the last element of the column values (which is (1,0)) and adds it to the first element (which is the frog's current position).

<b094>

What's good about this approach is that it lets us do many things at once, within the context of a single matrix multiplication. In order to illustrate what I mean by this, let me show you a slightly more advanced example.

@@<hr>
@@<h3><b>Simultaneous Movements</b></h3>

Let us imagine that, in addition to moving the frog to the right by 0.5, we also want to move it downward by 0.5. This corresponds to the act of adding (0.5, 0.5) to the frog's current position, which yields the new position: (1.5, 1.5).

<b095>

How to add the value of 0.5 not just to the frog's X-coordinate, but also to its Y-coordinate?

If we look back at the previous data table, we can clearly see that the extra row we added has (1,0) in it as its "position" value. We have seen that, by scaling this row by 0.5 (which turns (1,0) into (0.5,0)) and adding it to the frog's row, we are able to add 0.5 to the frog's X-coordinate.

<b093>

Since the Y-coordinate of this special row is 0, however, we are unable to make it change the frog's Y-coordinate no matter how much we scale it.

In order to move the frog vertically, therefore, we need another special row designed to shift its Y-coordinate. Let us add a new row, this time with the "position" value of (0,1) instead of (1,0).

<b096>

Then, guess what. Now we are able to shift our frog's position both horizontally and vertically, by adding scaled versions of both the 5th row and the 6th row. The 5th row has (1,0) in it, so scaling it by 0.5 and adding it to the frog's row will shift the frog's position by (0.5,0). Meanwhile, the 6th row has (0,1) in it, so calling it by 0.5 and adding it to the frog's row will shift the frog's position by (0,0.5). Together, they end up shifting the frog's position by (0.5,0.5).

<b097>

Aside from technical details, the overarching idea is that the extra rows we just added (i.e. (1,0) and (0,1)) are the fundamental building blocks (aka "basis") out of which any motion can be composed. Think of these rows as a pair of buttons you can press to move the frog.

@@<hr>
@@<h3><b>Packing Multiple Events</b></h3>

So, what makes this solution particularly attractive, as opposed to just writing up a column of position values and adding it to the existing one (like the one shown below)?

<b092>

The answer is that it lets us pack a variety of events in a single matrix multiplication. Suppose, for example, that our items possess not only positions, but also energy numbers as their properties.

<b081>

Now imagine that our frog, initially located at (1,1), decided jump on top of the apple (which is located at (2,2)). By the act of jumping, the frog consumed a bit of its energy, thereby decrementing it from 5 to 4.

<b098>

If we model this set of events as a set of transformations in our data table, they will looks like the ones shown below. Here, you will see that the frog's position changed from (1,1) to (2,2), while the frog's energy changed from 5 to 4.

<b099>

The question is, how to execute these two separate changes? Technically speaking, we can definitely choose to first split up the table into individual columns,

<b082>

Individually update the position-column and energy-column by adding two different column values to them,

<b100>

And then recombine the resulting columns to obtain the modified data table. Pretty straightforward! However, this approach is too cumbersome in the sense that it requires us to separate out the columns and go over a multitude of additions just to simulate the effect of a frog losing a bit of its energy while jumping.

A much more scalable method is to carry out all the required transformations inside a single matrix multiplication. In order to do that, we will first need yet another extra row in our data table (besides the ones for X,Y movements) which serves as a building block for modifying an item's energy value. It is a row which has the value of 1 in its energy-column and 0 everywhere else.

<b101>

With this new tool, we can then update both our frog's X,Y coordinates AND its energy value simultaneously (See the picture below).

<b102>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-02

[Linear Algebra for Game Development - Part 8] September 2, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 8 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Anatomy of the Game World</b></h3>

We have seen so far that there are two alternative manners in which our gameplay universe can be modeled. Firstly, I introduced a model where the game world is partitioned into distinct regions, each of which can be considered a separate physical space.

<b029>

Later on, I introduced a better model where the position of each item (object) is represented not by the position of its corresponding data entry in the list, but by an explicit "position" value which is written inside the data table.

<b080>

Here is something I missed, though, which I ought to go over before showcasing other concepts.

Initially, I proposed the feasibility of allowing both the physical game world and the player's inventory to coexist within the same gameplay system, by partitioning the data table into two distinct regions - one for the world, and the other one for the inventory.

<b038>

This made sense because, in this early model, the table itself could be thought of as a direct physical analogue of the actual gameplay space. Splitting the table into two groups of rows, therefore, was practically the same thing as splitting the game's physical space into two areas.

But then, as I introduced the concept of representing positions as numerical properties (i.e. explicitly written values), such a one-to-one correspondence between the data table and the physical space suddenly disappeared. Since each row is no longer bound to a fixed point in space, we can no longer generate two spatial volumes by partitioning the table into two groups of rows.

<b080>

@@<hr>
@@<h3><b>Domains</b></h3>

And the problem is that, for rich gameplay experience, we need separate spaces in our game which are designed to serve different purposes. We want the inventory besides the world, so as to let the player open up his inventory as a simple UI menu at any point in time by just clicking a button on the screen. Otherwise, the player will have to physically carry every one of his items whenever he moves from place to place.

Let us revisit our previous example, in which our data table consisted of 7 rows - 4 for the inventory items, and 3 for the basis of position/energy modification.

<b101>

Now imagine that, in addition to inventory items, we also want to have the actual gameplay space (i.e. some 3D environment, filled with physical objects), in which we can see and control the player character.

How to establish this kind of division? For this purpose, we first have to explicitly label our data table's rows with the domains to which they belong. We can achieve this goal by introducing a new column called "Domain".

<b103>

As you can see, our 3 inventory items (i.e. frog, diamond, and apple) now have "inventory" as their domain values. This means that these 3 items are all located within the inventory.

Now, let us add an additional row to represent our player who resides not in the inventory, but in the game world (i.e. the actual physical space where gameplay happens). In order to denote such a relation, we can set the term "world" as the player's domain.

<b104>

Here we have two different domains - the world and the inventory. The world is the physical space in which the player lives. The inventory, on the other hand, is a completely isolated space which is filled with the player's items.

These two domains possess their own coordinate systems. The pair (1,1), for instance, may either indicate the position of the player or the frog, depending on whether the domain is set to "world" or "inventory".

<b105>

Although domains are isolated chunks of space, it is possible to "teleport" an object from one domain to another by simply converting its domain value. If you want to pull the apple out of the inventory and place it right in front of the player, for example, you can accomplish this task by modifying not just the apple's position, but also its domain (from "inventory" to "world").

<b106>

Changing the domain, though, may seem impossible at first because it is not a number (which means we cannot add or subtract it inside a matrix multiplication). As we put a little bit of thought to it, however, we begin to realize that we can bypass such an obstacle by assigning a numerical value to each domain value. For instance, nothing prohibits us from supposing that number 1 indicates "world" and number 2 indicates "inventory" (0 indicates "no domain").

<b107>

Based upon this these rules, we can then proceed to either increase or decrease an item's domain value by adding/subtracting a number. Here is how we can do it. First of all, let us make yet another row in our data table, whose values are all zero except the domain part which is set to 1.

<b108>

This new row lets us change the domain of any item. Since the current domain of the apple is 2 (inventory) and the goal is to turn it into 1 (world), all we have to do is subtract it by 1, which is equivalent to the subtraction of the apple's row (i.e. 4th row) by our new row (i.e. 8th row).

Besides doing this, of course, we will also need to change the Y-coordinate of the apple's position in order to place it in front of the player. The full process is illustrated below.

<b109>

@@<hr>
@@<h3><b>Transforming the ID</b></h3>

In the same spirit, we also have the ability to transform one type of object to another simply by offsetting its ID value.

Here is an example. Imagine that a sorcerer cast a magic spell to the player, turning him into a frog.

<b110>

How shall we make this transformation happen in our game? The solution is pretty similar to the one we saw in the previous case. Just like what we did with the domain, the first thing we ought to do is assign a number to each ID value.

<b111>

Now that we are representing our IDs with numbers, we are now able to convert one ID into another simply by shifting its numerical value. Since the player's ID is 1 and the frog's ID is 2 in our example, we can turn the player into a frog by adding 1 to his ID.

<b112>

In order to perform this addition in the context of linear algebra, though, we will first need to append yet another row to our data table. This brand new row, which has 1 (unit value) in its ID column and 0 (no value) in every other column, will let us shift the ID value of any object by any amount we want.

<b113>

By adding this row to the player's row, we can effectively add 1 to the player's ID, thereby changing the identity of the player to that of the frog.

<b114>

@@<hr>
@@<h3><b>How to Ban Magic</b></h3>

But, if you are annoyed by sorcerers who are habitually turning people into frogs without facing legal repercussions, you may want to ban them from exercising such a sort of magic altogether. And you know what? You can enforce such a rule by erasing the "1" from the last row we just added, which can be done by zeroing out the entire row.

<b115>

This will block anyone from modifying the ID value anywhere inside the game. Henceforth, if you attempt to turn the player into a frog by adding 1 to his ID value, you will be able to confirm that the player's ID won't change because adding an all-zero row has no effect (See the picture below).

<b116>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-06

[Linear Algebra for Game Development - Part 9] September 6, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 9 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Building Blocks</b></h3>

Let us recall the data table we have been examining so far. It is reproduced below.

<b113>

At this point, you may have realized that the content of our data table can be divided into 3 major groups - (1) rows which belong to the world, (2) rows which belong to the inventory, and (3) rows which do not belong to anywhere.

<b117>

As long as a row has an ID associated with it, we can imagine it as a uniquely identifiable object in our game - whether it be the player, an item, an enemy character, a sprite, a particle effect, or whatever. It is something which possesses its own identity, which makes it distinguishable from every other row in our data table.

Rows whose ID values are empty (zero), on the other hand, are quite special in the sense that they cannot be distinguished from one another based upon their IDs. Instead, they must be distinguished based upon the roles they play in the context of creation, destruction, and transformation.

Previously, I had mentioned that these special rows are "building blocks of transformation" when it comes to shifting the numerical properies of each object by some predetermined amounts (i.e. constants).

<b118>

However, it is equally true that the objects themselves are made of such building blocks in the first place, just like physical entities (i.e. materials) are made of atoms. By composing these fundamental units of existence, we can give birth to any type of object.

A list of building blocks is basically a toolset which the gameplay system can leverage to create anything which is able to be generated out of their combination. Here, let me demonstrate what I mean by this. First of all, let us create a data table which is only made up of building blocks and nothing else.

<b119>

This table represents an "empty universe". It is empty because there is no object in it - no player, no item, nothing whatsoever. However, it still has the potential to bring a plethora of things into existence because it is equipped with a set of construction materials which, when combined, can manifest themselves into tangible bodies.

@@<hr>
@@<h3><b>How to Spawn</b></h3>

As we all know, an empty universe is boring. Since there is no object occupying it, its infinite horizon of vacuum is ruled by complete lethargy, never venturing to utter a spark of curiosity. In order for something interesting to happen in this universe, therefore, we must fill it with new objects.

To kickstart such a process, let me first spawn a frog in this ocean of emptiness.

<b120>

How to spawn a frog? To achieve this goal, we need to take two major steps. First, we will need to create a brand new frog. Second, we will need to put that frog into the universe.

Let me begin with the first step - creating a frog. Suppose that the new frog I am trying to make is located at the position of (1,1), belongs to the inventory, and has the energy level of 5.

<b121>

Conjuring this particular frog out of nowhere might feel like a daunting task, but it will turn out to be pretty easy if we imagine the frog as a combination of building blocks.

For instance, think of it as the result of combining 1 copy of the X-position building block, 1 copy of the Y-position building block, 5 copies of the energy building block, 2 copies of the domain building block, and 2 copies of the ID building block.

<b122>

This process, in fact, can be expressed as a matrix multiplication like the one shown below. Here, we are multiplying our empty universe (i.e. list of building blocks) by a row vector whose numbers tell us how many copies of each of the building blocks we need to collect in order to assemble the aforementioned frog.

<b123>

Okay, this completes our first step. We now know how to create a frog.

Let us move on to the next step. Here is the question which needs to be answered: How shall we put this frog into the universe?

Remember that our universe is currently empty; it consists only of building blocks (Nothing tangible yet whatsoever).

<b119>

In order to place our new frog in it, therefore, we must add a new row to the table and fill it up with the frog's content. We can accomplish this by generating a copy of our original data table, and then making sure to attach an extra row to it which represents the frog.

The former can be achieved by selecting all of the original rows in the same order as before, and the latter can be achieved by also "selecting" a particular combination of the building blocks which results in the frog.

<b124>

This is how we can spawn a frog inside the game.

@@<hr>
@@<h3><b>How to Despawn</b></h3>

Now that we know how to spawn a frog, it is time to ensure that we are also able to despawn it at some point in time. If we happen to keep adding more and more frogs to the world without any means of getting rid of them, it will eventually end up having no room for anything but frogs.

How to destroy a frog? Or, more generally speaking, how to destroy something which is part of the universe? Remember that each "thing" is essentially just a row in the data table. Each row represents a thing (aka "object") which is located somewhere in the game world, and its column values represent the thing's properties (such as "ID", "Domain", "Position", etc).

<b043>

If we want to get rid of a single "thing" from our universe, therefore, we will have to delete the data table's row which corresponds to it.

First of all, we can clearly tell that when we select "nothing" at all (by selecting none of the rows in the table), we end of just getting an empty row, whose values are all zeroes.

<b125>

An empty row like this, such as the one illustrated above, corresponds to a chunk of empty space (i.e. vacuum).

The act of despawning our frog, then, will be equivalent to the act of simply transforming the frog's row into an empty row, while keeping the rest of the table the same as before. And the way we do this is depicted below.

<b126>

Here, you can see that we are selecting "nothing" in place of the frog's row, thereby clearing it out entirely. Meanwhile, we are also selecting all the other rows of the table in the same exact order as before, thereby preserving them without any modification.

@@<hr>
@@<h3><b>Pre-Allocation</b></h3>

We've seen that it is fairly easy to create and destroy things. As long as we know the right recipe for the type of object we want, we must be able to spawn it anywhere as well as despawn it at some point in time.

There has been a bit of inconvenience, though, in terms of the size of the data table. As you saw in the previous example, adding a frog to the world made us attach an extra row to the table, which inevitably changed its height from 5 rows to 6 rows.

And you know what? If we wish to add another frog to the world, we will then have to multiply our data table by a matrix of a different size so as to grow the table's height from 6 rows to 7 rows, like the example shown here:

<b127>

And guess what? If we want to add yet another frog, we will have to come up with yet another matrix whose size is different from the previous ones, so as to grow the table's height from 7 rows to 8 rows, and so on.

This kind of inconsistency is pretty annoying, and we would like to avoid that. Fortunately, there is a simple way to prevent this. The only thing we need is to pre-allocate a bunch of empty spaces at the very beginning, so that we won't have to increase the table's size to make room for a new object.

<b128>

The number of such empty spaces is the same as the maximum number of objects which can simultaneously occupy the world without having to expand its volume. In the picture below, for instance, we are clearly able to spawn 4 frogs without changing the table's size at all.

<b129>










:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-10

[Linear Algebra for Game Development - Part 10] September 10, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 10 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Resurrection</b></h3>

In the previous article, we saw that it is not so hard to create a new object (such as a frog), introduce it to the world, and then destroy it later on. All we had to do was fill up a row in the data table with some combination of building blocks to spawn something, and then clear out that particular row once we decide to despawn it.

<b130>

Here is a potential problem, though. When we erase a row (by turning every one of its column values to 0), there is no way to recover its original values, meaning that we are unable to revive something we just killed.

This, of course, makes perfect sense in ordinary life because (unless a miracle happens) a living thing simply cannot come back to life after it dies.

Since a game is a work of fiction, however, it is often fun to grant ourselves a magical power to raise the dead from their graveyard. How shall we implement such a power?

If we want to be able to bring the dead back to life, we must stop completely annihilating something whenever we decide to kill it. To explain the reason why, let me suppose that there is a frog inside the world, like the one shown here.

<b131>

If we kill this frog by simply erasing it (without making a backup), it will be gone forever! There will be absolutely no way to bring it back to existence, since we won't have access to the piece of information we need ("1 1 5 2 2") to reconstruct the original frog.

<b132>

In order for resurrection to be viable, therefore, we need to have some kind of "backup storage" in which we can temporarily store the dead frog, so as to be able to bring it back to life later on. To make room for such a storage, we need to partition the world into two distinct parts - Earth and Heaven.

<b133>

From now on, when we decide to kill the frog, we will move it over to Heaven instead of just erasing it. Think of Heaven as the frog's backup storage, hosted on the cloud.

<b134>

Later on, if we want to resurrect the frog, we will simply need to bring it back to Earth. That way, we will successfully recover the original copy of the frog without having to remember and reconstruct it by ourselves.

<b135>

And the way we implement this is easy. All we need to do is change the frog's domain from "Earth" to "Heaven" when it dies, and change it back to "Earth" when it revives.

<b136>

This kind of transformation, indeed, will need to be modeled in terms of numerical operations. For such a purpose, let us begin by assigning numbers to our domains. For example, let's say that Earth is 1 and Heaven is 11.

<b137>

What sort of action, then, will we need to take if we want to kill the frog (i.e. teleport it from Earth to Heaven)? Oh, the answer is crystal clear. Since Earth is 1 and Heaven is 11, we know that adding 10 to Earth will turn it into Heaven. Therefore, if the frog is currently on Earth (1), the only thing we will need to do is increment the domain's value by 10 to change it to Heaven (11).

The opposite scenario is equally straightforward. If the frog is in Heaven (11) and we want to bring it back to Earth (1), all we need to do is decrement the frog's domain by 10.

<b138>

In the language of matrix multiplication, it is evident that multiplying the domain's building block by 10 and adding it to the frog's row is equivalent to increasing the frog's domain by 10. If the frog is currently on Earth (1), executing such an operation will move it over to Heaven (11). This is how we kill a frog.

<b139>

If we multiply the domain's building block by 10 but subtract it from the frog's row instead, the frog's domain will decrease by 10 (instead of increasing). If the frog is currently in Heaven (11), therefore, executing such an operation will move it back to Earth (1). This is how we resurrect a dead frog.

<b140>

@@<hr>
@@<h3><b>Multiple Heavens</b></h3>

"But, what about the inventory?" you might ask. And in fact, you are absolutely right that the method I just described does not take the idea of inventory into account.

Previously, I had mentioned that it is often necessary to split our game into multiple spatial realms such as "world" and "inventory", where the world refers to some kind of 3D space in which physical interactions happen, whereas the inventory refers to some kind of 2D grid in which items are being stored, and so forth.

<b141>

A question may arise, then. What is going to happen if a frog in the player's inventory suddenly dies? Will it go to some kind of "inventory-heaven", as opposed to "world-heaven"?

Some people may argue that such a division is unnecessary, yet here is an important point to keep in mind. When a frog in the inventory dies, goes to Heaven, and then comes back to life, at which place will it respawn?

It may be argued that it doesn't really matter, and that the place of resurrection can be wherever we want, but here is an example which will prove that such a claim is groundless. Imagine that a vampire dies and is buried in a coffin. When it comes back to life, at which location shall we expect to see the vampire again? The same exact coffin, of course!

Therefore, if a frog dies in the inventory and comes back to life later on, we should be able to see the resurrected frog in the inventory, rather than somewhere else. The rule of thumb is that, whenever something dies and then comes back to life, it should respawn right at the place of its most recent death.

In order to ensure that this is the case, we must come up with a separate heaven for each domain - one for the world, and another one for the inventory.

<b142>

When the frog dies in the inventory, it enters the inventory-heaven (which is the place where dead inventory items hang out before they decide to reincarnate).

<b143>

The frog stays there, up until the point at which it happens to resurrect. When such a moment comes, it exits the inventory-heaven and respawns in the inventory (i.e. the place it left when it died).

<b144>

The same logic applies to the world and its corresponding world-heaven. If the frog were within the world (instead of the inventory) while it was dying, it would have entered the world-heaven rather than the inventory-heaven, and would have come back to the world again when it revived.

And, just like in the case of Earth and Heaven, we can assign distinct numerical values to the aforementioned earthly domains and their respective heavenly domains (like the ones shown below).

<b145>

Here, you may have noticed that the world-heaven differs from the world by 10, and that the inventory-heaven differs from the inventory by 10. This means that, whenever we add 10 to a domain, we will obtain its associated heaven to which the domain's residents will go when they die.

So, for example, let's assume that our frog is currently residing in the world. We can kill it by adding 10 to its domain value, which will change its domain from the world (1) to the world-heaven (11). Afterwards, we can revive the dead frog by subtracting 10 from its domain value, which will change its domain back to the world.

<b146>

In the case of the inventory, too, we can kill the frog by adding 10 to its domain value, which will change its domain from the inventory (2) to the inventory-heaven (12). And then of course, we can revive the dead frog by subtracting 10 from its domain value, which will change its domain back to the inventory.

<b147>

Note here that, regardless of whether the frog is in the world or the inventory, we can always just add 10 to its domain to kill it, as well as subtract 10 from its domain to revive it. This kind of consistency allows us to deal with life and death without having to keep track of who is in the world, who is in the inventory, etc.










:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-14

[Linear Algebra for Game Development - Part 11] September 14, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 11 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Multiple Levels of Heaven</b></h3>

It is now pretty obvious that, by assigning numbers to our domains (e.g. world, inventory, etc), we can simply represent the process of death as the increment of one's domain value by a fixed amount (such as 10), and the process of birth as its inverse (i.e. decrement).

<b146>

Since both domains and their respective heavens are being expressed numerically, we should be able to imagine them as points on a number line, such as the one illustrated below. Here, the point at "1" indicates the world, whereas the point at "11" indicates the world-heaven.

<b148>

When somebody in the world dies, he enters the world-heaven. This is done by adding 10 to his domain value (because the world is located at 1 and the world-heaven is located at 11). If he happen to reincarnate while he is in the world-heaven, we will bring him back to the world by subtracting 10 from his domain value.

And, just like we saw before, there could be multiple domains in Heaven as well as multiple domains on Earth. If we do suppose that 1 and 2 refer to the world and the inventory, respectively, as well as that 11 and 12 refer to their corresponding heavens (i.e. "world-heaven" and "inventory-heaven"), we can plot them as two pairs of points on the number line, such as the one shown here:

<b149>

In this diagram, you will clearly be able to tell that the number line is divided into two regions.

The points on the left region represent earthly domains which are being dwelled by living creatures, whereas the points on the right region represent heavenly domains which are being dwelled by ghosts.

The act of moving a point to the right by the distance of 10 (aka "adding 10"), then, has the effect of moving the point from Earth to Heaven. In contrast, the act of moving a point to the left by the distance of 10 (aka "subtracting 10") has the effect of moving the point from Heaven to Earth.

Here is a question, though. What happens when we kill something which is already dead (i.e. already in Heaven)? The answer is, it will enter what we could refer to as the "level 2 heaven".

The first time something dies while it is on Earth, it will enter the "level 1 heaven". The next time it dies, it will level-up to the heaven's heaven, which is "level 2 heaven" (Level 0 refers to Earth; it's the "ground level" after all).

<b150>

And of course, each level itself may comprise multiple domains. At level 0, we have both the world (1) and the inventory (2); these two realms are the ones in which living things reside. At level 1, we have the world-heaven (11) and the inventory-heaven (12). At level 2, we have the world-heaven's heaven (21) as well as the inventory-heaven's heaven (22).

@@<hr>
@@<h3><b>Spectrum of Domains</b></h3>

And you know what? We can extend the aforementioned definition to infinity, so that the act of killing/reviving will make sense no matter what the current value of the domain is.

The truth is that nothing stops us from making things up, since our gameplay universe is purely fictional. With this in mind, let us assume that there are infinite levels of heavens, as well as infinite levels of "antiheavens" which correspond to negative domain values.

<b151>

So, if you happen to "resurrect" while you are still alive, you will enter the level 1 "antiheaven" (instead of heaven) due to the extra layer of life you just acquired. If you get killed while hanging out in this antiheaven, you will be transferred back to the land of living creatures (i.e. Earth).

The general idea, though, is that such an extended definition lets us imagine that there is an infinitely long line of domain values (just like a line of real numbers in mathematics). In this model, we can shift any domain value by 10 however many times we want, and the result will still be a fully legitimate domain value.

<b152>

This kind of unboundedness allows us to imagine the so-called "domain" as just another dimension in space.

<b153>

In this alternative model, the act of killing somebody is the same as pushing him in the direction of the domain axis by the distance of 10, and the act of reviving somebody is the same as pushing him in the opposite direction by the distance of 10.

<b154>

@@<hr>
@@<h3><b>Multikill</b></h3>

"Okay, so what's the use of such an abstract model?", you might ask. Here, I will show you a reason why expressing life/death in terms of a spectrum of numbers is so useful.

Suppose that there are 4 frogs in our game, and we want to kill them all by dropping a nuke or something. This sort of event is not so uncommon in a video game, by the way. The player might for example be equipped with a special weapon which, when deployed, will annihilate everything in the known universe.

<b155>

Here is a problem, though. Imagine that the kind of weapon we are about to drop is not just a regular nuke, but some kind of "pandimensional nuke" which is capable of destroying the lives of not just those who are here on Earth, but also those who reside in heavens, antiheavens, and every other supernatural realm we can think of.

So, for example, imagine that each of the 4 frogs in our game exists in a separate domain, and that two of these domains do not even belong to Earth; one of them is a heaven, and the other one is an antiheaven.

<b156>

How, then, are we going to "kill" all of these frogs simultaneously? One of them is already dead (i.e. It is in Heaven), and the other one is anti-dead (i.e. It is in Antiheaven). Will it even make sense to "kill" something which is either already dead or anti-dead?

And the thing is, yes! It absolutely makes sense to kill something regardless of its current state of life/death. The reason is that the process of killing is nothing more than the addition of number 10 to one's domain value.

For the sake of demonstration, let me list the aforementioned 4 frogs as rows in the data table.

<b157>

As you can see, their domain values are different from each other. The first (topmost) frog belongs to the world, the second frog belongs to the inventory, the third frog belongs to the level 1 inventory-heaven (i.e. This frog is dead), and the fourth frog belongs to the level 1 world-antiheaven (i.e. This frog is anti-head).

The way we kill all these 4 frogs is surprisingly easy from a computational point of view. The only thing we have to do is keep them as they are, while making sure to add 10 to each of their domain values. This can be done by adding 10 copies of the "domain building block" to each of the first 4 rows of the data table.

<b158>

And the effect of doing this can be stated as the following:

- The frog in the world (1), after being killed, entered the level 1 world-heaven (11).
- The frog in the inventory (2), after being killed, entered the level 1 inventory-heaven (12).
- The frog in the level 1 inventory-heaven (12), after being killed, entered the level 2 inventory-heaven (22).
- The frog in the level 1 world-antiheaven (-9), after being killed, entered the world (1).

<b159>

What happened here is just a verbose description of the fact that we just "moved" all these 4 frogs by the distance of 10, in the direction of the domain axis.

<b160>

And the result of every one of these movements is guaranteed to make sense, since the distance between every domain and its respective heaven (i.e. the place to which the domain-dweller goes when it dies) is always 10.











:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-18

[Linear Algebra for Game Development - Part 12] September 18, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 12 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Column Building Blocks</b></h3>

Let me revisit the methodology I just introduced recently. As you may remember, it is possible to kill (i.e. send to Heaven) all of the frogs in our gameplay universe by simply adding to them multiples of the "domain building block", which is just an extra row attached to the data table.

<b158>

In the picture above, for instance, I am multiplying the 8th row of the table by 10 and adding it to every frog-occupied row. This has the effect of adding 10 to every frog's domain value.

There is something which bugs us, though. As you can see in the matrix, we are responsible for filling out 4 entries with number 10 to be able to kill 4 frogs. This seems like a trivial matter, but imagine that there are 1000 frogs in total, and that we are trying to kill all of them at once. This means that we will have to fill out 1000 entries in the matrix, which is too much work to do.

Fortunately, there is a nice shortcut.

In order to to explain how this shortcut works, let me first mention that all of the so-called "building blocks" we have been dealing with are rows, instead of columns.

<b157>

Here, we are seeing 5 distinct building blocks out of which a frog can be made - one for the frog's X-position (5th row), one for the frog's Y-position (6th row), one for the frog's energy (7th row), one for the frog's domain (8th row), and one for the frog's ID (9th row).

Building blocks, however, are not required to be in the form of rows. We may as well devise them as columns, which in some circumstances is more appropriate than having them as rows. And I will show you why.

<b161>

Take a look at the table above. Do you see an extra column, filled with all 1s? We can interpret it as a building block, too. In this particular case, it represents a building block of what we could refer to as "uniform change" - an act of shifting the values of an entire column by a fixed amount.

It turns out that, by means of a matrix multiplication on the right side (since we are dealing with columns instead of rows), it is possible to scale this extra column by the factor of 10 and add it to the "domain" column of the data table. This yields a uniform shift in the domain value of every row by 10.

<b162>

And of course, we know the meaning of such a transformation. It indicates a simultaneous death of every frog in the universe.

The same exact building block can be used for the periodic decay of energy in every frog. Let me come up with an example for the purpose of demonstration.

As common sense tell us, animals must keep spending energy in order to stay alive, and frogs are not an exception. An accurate simulation of our real world would be one which reflects such a concept.

<b163>

And the way in which we can implement it turns out to be simple as long as we just leverage the extra column we added. Just scale it by -1 and add it to the "energy" column of the data table, and you will see that the energy of every single frog will decrease by 1.

<b164>

We can carry out such an operation over and over on a periodic basis. This way, we will be able to let every frog consume a single unit (= 1) of its stored energy each time the clock ticks.

@@<hr>
@@<h3><b>Alternation</b></h3>

What if we wish to drain the energy at half the rate, though? That is, what if our intention is to drop each frog's energy by 0.5 instead of 1 at each step in time (on average)?

One may say that we must be able to achieve it by subtracting only half (= 0.5) of the rightmost column from our "energy" column, but let us assume that energy can only be an integer (due to each unit quantity (= 1) being an indivisible energy particle).

<b165>

In such a case, we are unable to subtract only a fraction of a unit of energy and thus have to look for another solution.

Fortunately, there is one neat way in which we can produce the effect of reducing each frog's energy at half the rate. It works by dividing our frogs into two groups, and decreasing the energy levels of only one group at a time (in an alternating manner).

<b166>

In order to do that, let us create two separate columns in our data table. The first one (5th column) is filled with [1 0 1 0...], whereas the second one (6th column) is filled with [0 1 0 1...].

<b167>

Notice the two opposing patterns here? Both of them are sequences of alternating 1s and 0s, yet the initial values at which they begin differ. One of them starts at 1, while the other starts at 0.

If we subtract the 5th column from the "energy" column, only the 1st and 3rd rows (i.e. frogs) will have their energy values dropped by 1. You can see how it works by looking at the formula below.

<b168>

If we subtract the 6th column from the "energy" column, on the other hand, only the 2nd and 4th rows (i.e. frogs) will have their energy values dropped by 1. It is because all the 1s and 0s are flipped in this case.

<b169>

Now, what is going to happen if we periodically carry out the two operations above in an alternating manner? That is, what sort of effect do we anticipate when we subtract the "energy" column by the 5th column, and then by the 6th column, and then by the 5th column, and then by the 6th column, and so on?

<b170>

The obvious efect we are bound to see is that of a train of alternating changes which, on average, reduces every frog's energy by 1 per each interval of 2 time steps (aka "2 matrix multiplications"), which means that the overall rate of energy reduction is 0.5 (= 1/2) per time step.

<b171>

@@<hr>
@@<h3><b>Using Two Types of Building Blocks</b></h3>

Let me now come up with something slightly more complex. Imagine that there are 4 frogs in the world, and that one of them killed the other ones by spending 4 energy points.

<b172>

This is such a typical gameplay scenario, right? A game character spending energy to kill its enemies (which in this, are the other 3 frogs) is, as you know, an all too common thing which recurs continually while playing a game. Oftentimes, one feels that it is a good idea to sacrifice one's resources to be able to fulfill a certain wish - an exchange between an end and its means.

In the aforementioned case of a frog consuming its energy to kill the other frogs, we are able to tell that there are two events happening simultaneously:

(1) The energy of one of the frogs being reduced by 4, and
(2) The other 3 frogs being sent to Heaven (i.e. their domain value being increased by 10).

In what manner shall we invoke these two events at once? For such a purpose, we will need both a row-based building block and a column-based building block, like the ones shown below.

<b173>

Here, the data table contains both an extra row which can be used for modifying the energy value of any row, as well as an extra column which can be used for modifying the domain values of all the frog-occupied rows except the first one.

Now, what do we need to do whenever we want to fiddle with the table's rows? The answer is, we multiply a matrix on the left side of the table.

And what do we need to do whenever we want to fiddle with the table's columns? The answer is, we multiply a matrix on the right side of the table.

So, now that you are reminded of these two important points, take a look at the arrangement of two matrix multiplications below. You will be able to tell, with a bit of analysis, what these two are doing.

<b174>

And you probably guessed it right. The matrix on the left subtracted 4 energy points from the first frog, and the matrix on the right added 10 to the domain of every frog except the first one.

<b175>

As you can see, it is possible to let our data table have building blocks both on its rows and columns, and use them simultaneously.









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-22

[Linear Algebra for Game Development - Part 13] September 22, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 13 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Conditionals</b></h3>

At this point, you may have noticed that something vital has been missing. And you probably guessed it right.

A game has a set of rules. When we are playing a game, we expect everyone to follow these rules. A more precise way of saying this is that there are conditions which must not be violated, and that there are events which are not allowed to happen if they do not satisfy these conditions.

Suppose that one of the rules in our game is that "energy" can never be a negative number. So, for example, if a frog's current energy level is 1 (as shown below):

<b176>

It will be okay for us to subtract 1 from it, since the resulting value (0) is still a nonnegative number. This is all good, everyone is happy, and no rule has been violated so far.

<b177>

But if we are to decrement the energy level by 1 once again, we will be in trouble. It is because turning the energy level from 0 to -1 is not allowed. It does not make sense for a frog to store a negative amount of energy in its body.

<b178>

And here is where a major technical difficulty arises. In the language of matrix multiplication, a rule such as "Energy cannot be a negative number" is not really enforceable.

When we multiply our table by a matrix, all it does is simply apply the same arithmetic operation to every one of its numbers; there is no way for it to block some of the entries from being modified if their results are deemed nonsensical.

How, then, shall we overcome this obstacle? The problem is that linear algebra, by definition, does not fair well with conditionals.

Whenever we select one of multiple potential outcomes based upon a condition, we inevitably introduce an "abrupt edge" in the landscape of the system's input/output pattern which would have otherwise been a nice straight line. Take a look at the graph below, for instance.

<b179>

This is a graphical illustration of the relationship between each energy value and its expected result when we attempt to decrement it by 1. As you can see, the numerical relation between these two stays linear (i.e. falls upon a straight line) as long as the original energy is a positive number. The moment we try to decrement energy which is already 0, however, a sudden change in direction occurs. This is where linearity breaks down.

And, as you may know, linear algebra is called "linear" because it primarily deals with things that are linear (straight) in nature, rather than those involving edges and curves.

How to circumvent this problem, then?

One potential solution is to try to "linearize" our nonlinear system by introducing variables whose linear combinations can somehow be interpreted as models of nonlinear phenomena (e.g. system of equations for an N-th polynomial), and so forth, but this kind of approach is way too abstract and is prone to confuse people who are not well versed in mathematics.

An easier alternative is to stop trying to use linear algebra for every single problem, and casually let us fall back to solutions which are not solely made up of matrix multiplications.

First of all, we all know that if we just keep repeatedly multiplying our data table by the same matrix which is responsible for reducing the frog's energy level by 1, we will soon see our frog's energy becoming a negative number (as shown below).

<b180>

It is because a strictly linear operation (such as a matrix operation) exhibits the same behavior everywhere on the number line. It does not care whether the frog's resulting energy level makes sense or not; it simply subtracts 1 from the existing number unconditionally.

In order to implement conditional behaviors, therefore, we need something other than just matrix multiplications, which is what I would like to call a "filter".

@@<hr>
@@<h3><b>Filters</b></h3>

Here is an idea. Why don't we just drop the frog's energy by 1 for now, without judging whether the resulting number will make sense or not?

<b181>

Immediately after doing so, we can then proceed to "clean up" any bit of the ensuing nonsense from our system.

For example, the above picture tells us that we turned the frog's energy level into a negative number (-1) because we decreased it even though it was already 0. This is obviously a nonsense, but it is a kind of nonsense which can be corrected afterwards.

Let us, for instance, attach an extra column to our data table whose topmost element may look a bit unfamiliar to you.

<b182>

Instead of a number, here is an invocation of a function called "MAX". The role of this function is to compute the maximum of the two values it happens to receive as its parameters, which are respectively denoted by "0" and "_" in our case. The underbar (_) refers to a blank which will be filled later on.

The next step is to multiply our table by a matrix (on the right hand side) which performs the task of adding this extra column to the "energy" column.

<b183>

And the result of this? Oh, of course, since we just added "MAX(0,_)" to the frog's nonsensical energy value (-1), the outcome is going to look like what is displayed below.

<b184>

Let me explain the meaning of this bizarre formula which was produced by our matrix multiplication.

<b185>

First of all, please excuse me for making up a rule which I guess is not part of "real mathematics". The rule is to assume that, if you "add" a function which contains a blank argument (i.e. "_"), we can move the preceding term (which is "-1" in our case) into the function and let it replace the blank.

<b186>

If we just let this happen, the rest will be straightforward. I ask you, what is the value of "MAX(0,-1)", which is what we get when we replace the blank with our -1? The answer is that it is 0, since the maximum value between 0 and -1 is 0.

<b187>

And since "-1 + MAX(0,_)" is equal to "0" according to our rule, it can be asserted that the result of the aforementioned matrix multiplication is the transformation of any negative energy value to 0.

<b188>

The matrix we just multiplied on the right side of the table to accomplish this job can be called a "filter", mainly because its role is to filter out negative values from the table's "energy" column by zeroing them out.

<b189>

This is just one of many possible examples. There can be countless other types of filters, which we may leverage for the purpose of solving a variety of problems involving conditions and their appropriate responses.

@@<hr>
@@<h3><b>Nonlinearity</b></h3>

To be fair, what I have just shown is not really part of linear algebra, since what the "MAX" function does is not even linear in nature. Thus, we should consider the aforementioned filtering step not as a legitimate type of computation in linear algebra, but instead as a nonlinear process.

<b190>

This, of course, is different from any of the previous operations we had seen before, since they all involved plain numbers (no nonlinear functions) and were therefore guaranteed to be linear.

Reducing the frog's energy by 1, for instance, is a linear process because it only multiplies and adds a bunch of numbers; it never does anything weird such as taking the maximum of two given numbers, etc.

<b191>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-26

[Linear Algebra for Game Development - Part 14] September 26, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 14 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Linear and Nonlinear Processes</b></h3>

What we just saw in the previous article is an example of collaboration between two types of processes - one of them being linear, and the other one being nonlinear.

<b192>

In our frog example, there is 1 linear process and 1 nonlinear process.

The job of the linear process is to decrease the frog's energy level by 1, thereby simulating the effect of the frog's periodic consumption of energy (An animal must keep burning its body's fuel to stay alive, you know).

The job of the nonlinear process, on the other hand, is to "filter out" erroneous energy values (i.e. negative numbers) by turning them back to 0. This way, we are able to guarantee that the frog's energy level will make sense no matter how many times the system tries to decrement it.

@@<hr>
@@<h3><b>Two-Step Cycle</b></h3>

In a away, therefore, we are able to imagine our gameplay system as a cycle of two alternating steps - one being linear, and the other one being nonlinear.

<b193>

During the linear step, we simply update the entries in our table by means of plain old matrices - that is, those involving numbers only, without any strange nonlinear operations such as the "MAX" function we saw before.

Right after doing this, we subsequently wrap up our results by conditionally adjusting them. This is something which should be done by a nonlinear step.

And for the sake of not only updating our data entries but also ensuring their sanity at all times, we must keep repeatedly executing the two aforementioned steps in an alternating manner. That is, once we update the table, we should then adjust it, and then update it again, and adjust it once more, and so forth.

<b194>

As you may have guessed already, the underlying pattern here is that each pair of the two alternating steps (i.e. "update" and "adjust") represents each cycle in the system's clock.

Each time we update our data table and then subsequently adjust its values, a cycle completes itself and the game's clock ticks once. And every time the clock ticks, we increment our current time by 1 (assuming that time is a sequence of discrete units, each of which is quantified by the value of 1).

<b195>

Note that each cycle contains two instances of the game's state (aka "snapshots"). Let us take a look at them individually.

<b196>

The upper one is the immediate result of the crude update process, which is purely linear and thus have none of the necessary adjustments applied yet. The lower one, one the other hand, is the finalized (i.e. adjusted) version of it.

Since the upper one is just an intermediate byproduct, we may as well just ignore it in the context of gameplay and only take the lower one as what is really happening in our game.

<b197>

The philosophy behind this two-step logic is quite clear; it is the decoupling between parts of the system which are linear, and parts of the system which are nonlinear.

Parts that are linear can easily be combined into a linear operator (such as a matrix multiplication), without forcing the developer to worry about violating the rules of linear algebra.

Meanwhile, parts that are nonlinear will have the privilege to be playing in their own playground without hurting the ego of mathematical fundamentalists whose highest achievement in life is that they have memorized every axiom in linear algebra and learned how to apply it without any exception.

@@<hr>
@@<h3><b>Global Properties</b></h3>

Speaking of gameplay cycles and their implication of the concept of time, I would like to mention one major thing which has hitherto been missing. It is the implementation of the universal quantity called "time", which exists independently of any individual objects in our game.

Take a look at the picture below.

<b198>

Here are 3 objects - a frog, a diamond, and an apple. Each of them possesses its own set of properties, such as energy, health, price, and so forth. Such properties describe the characteristics of these individual objects.

However, there could also be a property which exists independently, such as time.

Time does not belong anywhere; it is a number which is directly associated with the universe as a whole. Whenever we discuss anything related to time, we do not say, "My frog's time is 2:00PM". Instead, we simply say, "The time is 2:00PM" because time is a global property rather than something that is local to any specific object.

The question is, how to represent such an omnipresent being within the context of our data table?

<b199>

As you can tell from the image above, each row typically represents a "thing" in our game, such as a character, an item, or a prop. Therefore, it wouldn't really make sense to record the current time in one of such rows.

This kind of formulation, however, is not strictly necessary. We may just come up with a special row which will serve as the game's "global record" - that is, a list of data entries which are representative of the game as a whole, rather than mere portions of it.

<b200>

Here, for example, I justed added a new row and declared that its second column value indicates the universe's current time (which is apparently "12" right now).

Normally, numbers listed on the second column would all refer to domains to which the game's objects (e.g. frogs) belong. In our example, however, we are designating separate labels to the columns of our "universal row", which make it somewhat special and thus behave differently from any of the other rows.

@@<hr>
@@<h3><b>Time</b></h3>

How to let our time flow, then? That is, how to ensure that the clock is ticking, so that our time will periodically increase, from 12 to 13, from 13 to 14, from 14 to 15, and so on?

<b201>

To achieve such an objective, we need some way of adding 1 to the current time. And you what? For this particular purpose, we can just reuse the same "domain building block" we used before, when we were killing/reviving the frogs. Here, I will include this particular building block at the bottom of the data table (See the picture below).

<b202>

The role of the bottommost row here depends on its usage.

Whenever we add it to one of the "frog rows" (in which case it will be transforming the frog's domain value), it will play the role of a "domain building block".

<b203>

Whenever we add it to our "universal row" (in which case it will be transforming the universe's time value), on the other hand, it will play the role of a "time building block".

<b204>

Here is an idea. By accumulating this "time building block" in a periodic manner, we are able to simulate the passage in time. And the way we do this is not so different from what we have been doing so far with the so-called building blocks; we just add them to the rows we want.

We know that, in our case, the goal is to periodically increment the time by 1. This can be done by adding the "time building block" to the row of global properties, wherein the time value resides.

<b205>

As you can see, this operation is equivalent to the act of ticking the clock. Every time we multiply our table by the matrix shown above, we tick the clock (i.e. increment the time by 1). And we need do this over and over at regular intervals. This will keep the time flowing.

<b206>










:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-09-30

[Linear Algebra for Game Development - Part 15] September 30, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 15 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Scoring and Winning</b></h3>

Okay. Now that we have a special row in our data table which is dedicated to storing global numbers, it is now time to talk about one of the most important mechanics in the context of gameplay - winning.

In most cases, people play games in order to win. So it makes sense to assume that a game needs to have a winning condition which, as soon as it is satisfied, allows the player to win.

To decide at which moment the player is supposed to win, we must first come up with a way of measuring the degree of success that the player has achieved so far during gameplay. To fulfill such a purpose, let us create a global number called "score".

<b207>

The rule is clear. You win this game when the score surpasses (i.e. becomes greater than) the goal. Let's say that this goal is 100.

<b208>

Besides the score, we need another global property called "won" which explicitly states whether the player has won the game or not. This way, we will be able to tell at which moment we ought to stop playing and congratulate the winner.

<b209>

The following question, though, is: "What kind of value should be assigned to this 'won' slot?"

From a conceptual point of view, it might be sensible to simply set the value of "won" to either "YES" or "NO" (or any other pair of English words that are easy to understand), so as to make it crystal clear whether the game is won or not.

From a technical perspective, however, letting numbers and words coexist inside the same table usually turns out to be a hindrance to the consistency of logic. In our case, for example, using "YES" and "NO" as potential values of "won" necessitates us to translate the score (which is a number) to something that is not a number (i.e. a word in English).

<b210>

While it is possible to write an algorithm which accomplishes such a job, we should also be aware that it requires us to introduce an arbitrary set of rules (e.g. if-then statements) which unnecessarily complicates the way we compute things.

A more elegant approach is to use a number to represent the value of "won". This should work, since we can simply let 0 stand for "NO", and anything other than 0 stand for "YES".

<b211>

In this model, all we have to do to determine the value of "won" is to set the value of "won" to a nonzero number if the score is greater than 100, or zero otherwise.

<b212>

@@<hr>
@@<h3><b>Logic via Arithmetic</b></h3>

The question is, how?

Here, I will show you a hacky little trick which can be used to solve the aforementioned problem without even introducing a new mathematical operator. Take a look at the following expression:

<b213>

Do you remember that the outcome of the "MAX" function is simply the greatest of its arguments (which, in this particular case, are "0" and "Score-100" respectively)? With this in mind, please examine the formula I've shown here and see what it does.

And, yes. You probably guessed it right. The output depends on whether the score is greater than 100 or not.

<b214>

If it is greater than 100, the value of "Score-100" will be greater than 0, which will in turn suggest that the output of MAX will be equal to "Score-100" (since we know that the maximum number between 0 and "Score-100" will always be "Score-100" under such a circumstance). This is a positive number because "Score-100" is positive.

If "Score" is less than or equal to 100, the value of "Score-100" will be less than or equal to 0, meaning that the output of MAX shall be 0 (due to the fact that the maximum number between 0 and "Score-100" will always be 0 under such a circumstance).

Makes sense so far, doesn't it? A major difficulty, though, is that applying this MAX formula to the correct data entries may be tricky.

Luckily, however, we do have a way to mitigate such a trouble. As you may recall from Part 13 of the series, it is technically possible to do some nonlinear, function-based computations using a matrix. Take a look at the augmented table below, where I attached an extra column with the formula "MAX(0,_-100)" in it.

<b215>

What we want to do with this can be described as the following.

(Step 1) First, we want to put the game's current score into the tiny placeholder ("_") which is sitting inside "MAX(0,_-100)", thereby making it "MAX(0,Score-100)".

(Step 2) Next, we want to put the result of computing "MAX(0,Score-100)" into the "won" slot of the table, so as to make sure that the value of "won" will be set to a nonzero number if the score is greater than 100 (or zero otherwise).

<b216>

And the way we carry out the first step, as illustrated in Part 13, is to add the score to "MAX(0,_-100)". As long as we all implicitly agree that "_" is assumed to be the value of the other term which is being added. This should yield the desired outcome.

<b217>

@@<hr>
@@<h3><b>Divide and Conquer</b></h3>

Here is yet another thing which ought not to be overlooked. When it comes to implementing the aforementioned addition, we might be tempted to simply do a matrix multiplication like this:

<b218>

Its job is fairly straightforward; we just add the score's column and the MAX formula's column together and assign the resulting column to the one where the "won" value is located. This, without a doubt, yields the correct value of "won" based on the current score.

While doing this, however, it also inadvertently replaced the IDs of the frogs with their respective energy values. The reason is obvious; whenever we are adding a column, we are adding ALL of its entries in parallel!

Luckily, we already know a solution. If you recall the "splitting" method which was demonstrated in Part 5, you will notice that we can just split our table into smaller pieces and process them individually to bypass such an obstacle.

So, let us first divide our table into two segments, okay? The first segment will only contain the four frogs and their properties, which we are able to obtain by erasing the last row.

<b219>

The second segment, on the other hand, will only contain the last row (where global properties reside), which we are able to obtain by erasing the first four rows.

<b220>

We can then safely compute the "won" value of our game by simply adding columns in the second segment (See the picture below). I say it is "safe" because there's no frog that can be interfered with.

<b221>

After recording this new "won" value, all we need to do is bring the two segments back together so as to reconstruct the full table. And the way we do this is by simply adding these two segments up, on an element-by-element basis.

<b222>

The right side of the equation, which you can see in the picture above, is our desired result. The "won" value was successfully set to 0 (which means "You haven't won yet"), since the score is less than or equal to 100. If the score were greater than 100, the "won" value would've ended up being a positive number.

Anyways, the point I want to make is that it is possible to keep track of the game's state by means of adding and multiplying the table's entries. Think of it as some kind of office work involving spreadsheets, wherein you would often find yourself writing a function which reads values from a set of cells, processes them, and assigns the result to another cell.

And the truth is that the whole game might be represented as one big spreadsheet, in which you can establish the rules of play by writing such functions.











:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-10-04

[Linear Algebra for Game Development - Part 16] October 4, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 16 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Statistics</b></h3>

So far, I have introduced the concept of global properties as well as their use cases in the context of gameplay. The example I came up with was that of the logic involved in determining whether the player has won the game or not, based on the current score.

The next question is, how to calculate the score in the first place? Indeed, we ought to know the score first, in order to make any decision off of it. And to fill out this missing piece of the puzzle, I will demonstrate one possible way of computing the player's score.

Let us revisit our previous table, which tells us that there are 4 frogs in our game world. It is reproduced below.

<b209>

How to determine the current score of this particular game we are playing? Well! It really depends on what kind of game we are playing. Since there are only frogs here, it seems that the score should depend on what these frog are up to.

<b223>

If the goal of this game is to kill as many frogs as possible, it will make sense to calculate the score by adding up the number of frogs who currently reside in Heaven (= 11) instead of Earth (= 1). This is because, when you kill a frog, you are sending it to Heaven.

<b224>

If the goal is to put as many frogs as possible into some kind of "frog prison", on the other hand, we will have to calculate the score by counting the number of frogs whose positions happen to fall within the boundary of that prison.

<b225>

If the game is some sort of "frog power plant simulator" in which your mission is to store as much energy as possible inside your frogs so as to be able to charge your cellphone with them, the score will need to be the sum of all the energy points owned by your frogs.

For the sake of demonstration, let me implement this last scenario.

What we need to do to compute the score of a frog-based power generation game is pretty simple on a conceptual standpoint. All we need to do is just sum up the frogs' energy values and put the result in the "score" slot. Easy, isn't it?

A major challenge, though, inevitably reveals itself when we realize that it requires us to fiddle with only one of the columns of the table, and none of the others.

<b226>

Here, you can see that we are supposed to use only the "Energy" column for computing and storing the game's score. We are not expected to tamper with any other column, for otherwise it will produce nonsensical results.

Fortunately, we already know how to handle this kind of problem. All we've got to do is just split our table into parts, process them separately, and then merge them back together.

In our case, we want to do something with the "Energy" column only, and keep all the other columns untouched. This means that we need to split our table into two parts - (1) The "Energy" column, and (2) All the other columns.

By applying the following matrix multiplication, we can obtain the first part.

<b227>

And by applying the following matrix multiplication, we can obtain the second part.

<b228>

Now that we have the "Energy" column safely isolated from the rest, we are able to sum up the frogs' energy values simply by adding up their corresponding rows. Since only the "Energy" column contains nonzero values here, only the energy numbers will be summed up and nothing else.

<b229>

The only remaining step is to combine this intermediary result with the other split part to reconstruct the full table. Here, you can clearly see that the "score" slot of the final result contains the sum of all the energy numbers listed above.

<b230>

This is just one of many examples of gameplay. The main point, though, is that statistical analysis plays a huge role when it comes to the implementation of game mechanics.

Sometimes it may be as simple as taking the sum or average of a given list of data, or sometimes it may as well be as complex as deriving advanced statistical properties (such as "covariance" or "confidence interval") for the sake of obtaining deeper insights.

Modeling our game world as a table allows us to implement such concepts easily, without taking too much trouble dealing with structural complexities.

@@<hr>
@@<h3><b>Dealing with Diagonal Offsets</b></h3>

The score calculation we just did was fairly straightforward not because it is always guaranteed to be so, but because the particular case we were dealing with happened to involve only a single column. This made it possible for us to just ignore all the other columns.

<b226>

There could be, however, cases which are more complicated than this. Suppose that the "score" slot happens to be located in a different column. How on earth shall we manage to put the sum of the energy numbers in this location?

<b231>

An immediate solution would be to leverage the empty space which is right beneath the energy numbers. You see, the last entry in the column of energy numbers is not filled with anything, so we may just temporarily store the result of the sum there, and then move that value over to the final destination later on.

<b232>

But, what if there is already something which occupies the space underneath the list of energy values?

<b233>

In such a case, we will need to attach an empty row to the table and use it as a temporary storage instead (Think of it as a road, through which things can be transported). This will involve a three-step procedure: (1) Push the value into the storage, (2) Transport the value across the storage, and then (3) Pull the value out of the storage.

<b234>

There is a simpler way of doing this, though. Instead of moving the result of the sum downward, leftward, and then upward, we might as well consider temporarily swapping the destination entry with the one which belongs to the "Energy" column, calculating the score, and then swapping it back.

Here is how it is done. We first bring the "score" entry right underneath the individual energy numbers by means of a simple swap.

<b235>

We then take the sum of the energies and store it right underneath them (just as we did before),

<b236>

and then bring the updated "score" entry back to its original place by means of another swap.

<b237>

This alternative method is probably more elegant, since it does not require us to add an extra row to our table just to let it serve as a medium of transportation.

@@<hr>
@@<h3><b>Too Complicated!</b></h3>

All solutions mentioned so far, however, may feel a bit too painstaking. And you are absolutely right; it is such a pain, indeed, to be forced to undergo a number of cumbersome processes just to be able to manipulate rows and columns separately from one another.

The steps involved in modifying a single column (or row) can be summarized as the following. In the picture below, you will see that in order to make changes to a single column, we need to express the table as a sum of two sub-tables and then make sure to update only one of them.

<b238>

Algebraically, this kind of procedure can be formulated in the manner shown below. Here, it says that we must perform 3 matrix multiplications as well as an addition, just to record the sum of the frogs' energy numbers in the "score" slot.

<b239>

Therefore, it is now time to invent some kind of shortcut to let us do things more efficiently. We will go over this topic in the next article.









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-10-08

[Linear Algebra for Game Development - Part 17] October 8, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 17 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Shorthand for Row/Column Operations</b></h3>

In the previous article, we saw how much of a burden it is to go through a bunch of matrix operations just to modify a single row or column. The picture shown here, for instance, succinctly illustrates how hard it is to update just a single column in a table.

<b238>

Therefore, we need to come up with a notational shortcut to be able to express such a procedure more elegantly. For this purpose, let me introduce a special superscript which denotes that only a portion of the table should be touched. Take a look at the matrix multiplication below:

<b240>

You are probably already familiar with this example. It sums up the table's first 4 rows and assigns the result to the table's last row.

Note, however, that "Column 4" is written right above the matrix. This means that only the 4th column of the data table must be changed when the matrix gets multiplied. Its full algebraic expansion is shown below.

<b241>

Here, you can see that a "matrix" with the superscript "Column 4" is equivalent to performing two matrix multiplications and one matrix addition.

Of course, it is mathematically wrong to call this a "matrix", since it is a shorthand expression for denoting a multitude of matrix operations. Thus, it makes more sense to say that it is just an unconventional way of denoting what one may refer to as a "matrix function".

The biggest advantage of this new notation is that it allows us to just draw a single matrix to express the concept of partial manipulation.

In the picture below, for example, we can see that a single matrix is being used to denote the process of taking the sum of the frogs' energy values and registering it as the game's score.

<b242>

Notice how much easier it is to write it this way, in contrast to what we had done before.

@@<hr>
@@<h3><b>Shorthand for Diagonal Operations</b></h3>

Such a type of syntactic shortcut may also be extended to support any interaction between elements which are diagonally apart.

For the sake of demonstrating what I mean by this, I will revisit one of the previously mentioned scenarios - that of calculating the score AND putting the result in a different column (See the picture below).

<b233>

Here, we can clearly see that the "score" slot is located within the column of position values, instead of the column of energy values (from which the score is being derived). So the problem we are facing here is that we must transfer the result of the sum (of the energy values) diagonally, so as to let it land at the very bottom of the column of position values.

And a way we can accomplish this task has already been illustrated. First, we swap our "score" slot with the one that is right underneath the energy values.

<b235>

Then, we compute the sum of the energy values and put it into the "score" slot.

<b236>

Finally, we swap the two slots back in order to recover the table's original format.

<b237>

This 3-step process would've been a nightmare to carry out if we still insisted in manually splitting out the table into sub-tables, updating one of them, and then merging them back together in every one of these steps.

Fortunately, we are now equipped with a shorthand notation which lets us express the whole process in a much more elegant manner. In each step, all we need to do is draw a single matrix and attach a notation to it to tell in which portion of the table it is supposed to be operating.

Let me go through this step by step. First, we swap the 3rd and 4th columns inside the table's "Row 5" (5th row).

<b243>

Then, just as usual, we calculate and record the score inside the table's "Column 4" (4th column), by summing up the first 4 rows and assigning it to the last row.

<b244>

Finally, we swap the 3rd and 4th columns inside the table's "Row 5" (5th row) once again, just like we did in the first step.

<b245>

This completes our task of computing the score and putting it in a different column. If we gather all of these steps in one place, we will see something which looks like this:

<b246>

Each curved black line represents a parenthesis.

I am using parentheses here for the purpose of clearly defining the order in which these 3 steps need be executed (i.e. that a swap must happen first, score calculation must happen next, and then another swap must happen last).

Notice that each rectangular block of numbers shown here, while it graphically resembles a matrix, is not really a "matrix" in the algebraic sense.

Therefore, it is erroneous to assume that the properties of matrix algebra must also apply here. For example, it is wrong to suppose that these "pseudo-matrices" are associative in nature (i.e. that their order of multiplication doesn't matter).

This, as you may have noticed already, is the reason why parentheses are necessary in this case.

@@<hr>
@@<h3><b>Simple Diagonal Movements</b></h3>

Let us go back to one of the earliest in-game data structures we've seen in this series of articles - a 2D grid of items. The following image is an example of a 3x3 grid.

<b247>

The concept of diagonal data exchange, which I have recently illustrated, proves itself to be quite important in the context of a 2D inventory (such as the one shown here). Suppose, for instance, that the player wants to swap the frog with the cheese.

<b248>

How shall we accomplish this task? Oh, it used to be VERY challenging before the shorthand notation was introduced. Since we are armed with a much more succinct way of expressing movements, however, we can now approach this sort of problem without a rigmarole of painfully verbose algebra.

Here is how a quick swap between the frog and the cheese can be done. First, we select the 1st column of the inventory and exchange its 1st row with the 3rd row.

<b249>

Next, we select the 3rd row of the inventory and exchange its 1st column with the 2nd column.

<b250>

And then, finally, we select the 1st column and exchange the 1st and 3rd rows again.

<b251>

This completes the full swapping process (between the frog and the cheese). The full list of steps is summarized below.

<b252>

Please beware, though, that what is written here is just one of two possible solutions.

In the method shown above, we made a vertical swap, a horizontal swap, and then another verical swap to generate the effect of swapping the two items (i.e. frog and cheese).

On the other hand, it is also possible to generate the same effect by making a horizontal swap, a vertical swap, and then another horizontal swap instead. What's shown below is the summary of such an alternative solution.

<b253>

It is not so difficult to come up with a notational shortcut for quickly representing any kind of diagonal exchange. For this purpose, we first need to define the problem clearly.

In our example, our frog was located at the 1st row and 1st column of the grid (i.e. "Row 1 Column 1"), and our cheese was located at the 3rd row and 2nd column of the grid (i.e. "Row 3 Column 2"). Our mission was to swap these to locations.

<b254>

Let us express this particular swapping operation as a block, which contains the two target locations and a pair of arrows denoting the concept of an exchange.

<b255>

We can then say that this new notation is a shorthand for either one of the two formulas we saw before:

<b256>

Notice that there are only two distinct matrix expressions in any one of these formulas; one of them is used for horizontal swaps, and the other one is used for vertical swaps. After a bit of observation, you will be able to tell that the exact placement of the 1s and 0s in these matrices directly mirrors the two locations we are swapping.

<b257>









:d:This article explains how to use linear algebra in the design and implementation of video games.
:k:Linear Algebra, Matrix Algebra, Game Development, Game Design, Gameplay Systems, Game Engine, Technical Design, Numerical Methods, Scientific Computing, Gameplay Engineering
:l:2025-10-13

[Linear Algebra for Game Development - Part 18] October 13, 2025

@@<hr>
@@<h3><b>Before You Read</b></h3>

This article is Part 18 of the series, "Linear Algebra for Game Development". If you haven't, please read {%a href="https://thingspool.net/concepts-of-plan/page-7.html"%}Part 1{%/a%} first.

@@<hr>
@@<h3><b>Unique Identities</b></h3>

I have hitherto introduced quite a variety of gameplay concepts, such as birth/death, score calculation, winning condition, and so on.

There is one important topic which is yet to be discussed, though - the problem of establishing unique identities.

<b257a>

The table above defines a game world which consists of 4 frogs. These 4 frogs share the same exact identity (ID), symbolized by the the green frog-shaped icon.

Does this shared representation suffice in the context of the game? The answer is, it depends on how sophisticated the game is.

If it is okay to let these frogs be anonymous (i.e. not distinguishable from one another), we will happily stick with what we have been doing. In contrast, if it happens to be necessary to ensure that each one of these frogs be unique, we will need to assign a distinct ID to each frog. Let's say that each ID is a positive integer (Think of it as a personal identification number).

<b258>

Oh, but we still have to specify that these creatures are frogs rather than something else. Therefore, we will need two separate columns of data to represent our frogs - one for uniquely identifying them, and another one for classifying them as frogs.

<b259>

See? Here is a new column called "Type", which tells us what type of object the row is supposed to represent.

In the table above, the 1st row indicates a frog whose ID is 1, the 2nd row indicates another frog whose ID is 2, and so forth. The 4 rows represent 4 frogs, yet they are all unique because they all have different ID values.

<b260>

At this point, one may ask:

"Okay, what's the use of the ID value, then? Shouldn't the uniqueness of the row itself suffice when it comes to distinguishing one frog from another? Why not just assume that the 1st row corresponds to ID = 1, the 2nd row corresponds to ID = 2, etc?"

This makes sense, but only up to a certain extent. Suppose that we decided to destroy one of the frogs (Not just kill, but completely destroy). This means we will erase the data from the frog's row.

<b261>

Let's say that the frog with the ID of 3 was destroyed, meaning that we no longer have this frog in our game world.

<b262>

Imagine, now, that we made a decision to create a brand new frog. What shall we do to express it in our data table? Obviously, it is natural to allocate the 3rd row (which has been emptied out) to this new frog.

<b263>

The next question is, which ID should be chosen for this newcomer? It cannot be one of the existing ID numbers (i.e. 1, 2, or 4), since it will break the uniqueness of the IDs. It cannot be 3 either, since it will imply that the new frog is a resurrected body of the one we just destroyed.

This leads us to conclude that we must come up with an ID number which is different from any of the ones we used before. Since the ID of 1, 2, 3, and 4 have been used so far, it will make sense for us to assign the ID of 5 to our new frog.

<b264>

At this point, you can clearly see why we can't just use the row itself as a unique identifier. It is because any row can be repurposed to indicate something other than what it used to indicate.

In our case, the 3rd row used to refer to the frog whose ID was 3. Once this original frog was replaced by a new one, however, we had to mark the row with a new ID in order to distinguish the new from the old. This is why we need to have this explicit identifier called "ID", aside from the uniqueness of the row itself.

@@<hr>
@@<h3><b>Search by ID</b></h3>

There is yet another use case of IDs in our data table.

When playing a game, we often encounter moments in which a character selects another character (an enemy, for example) as its target and triggers some action against it, such as an attack, etc. And whenever such an event occurs, the systems takes the responsibility of applying the appropriate changes to the target such as a reduction in its HP (Health).

<b265>

In order for such a selective type of operation to be feasible, we need to ensure that there be some way of finding a character in the table based upon its ID.

How shall we do that? For the sake of simplicity, let us first reformat our table a bit to reflect a scenario in which one of the frogs happens to attack another frog and applies damage to it (e.g. drops its health by some amount). For that, we will just imagine here that each frog possesses only one property called "health" (aside from its ID and type).

<b266>

The problem we are trying to solve is to find the attacked frog by its ID, and then decrement its health. Let's assume that the attacked frog's ID is 5.

<b267>

The very first thing we ought to do is search for the row whose ID is equal to 5. And the way we do that? Oh, well! Let us solve this problem step by step. For now, just focus on the table's "ID" column only, and pretend that nothing else exists.

<b268>

Our mission is simple. Inside this column of IDs, we want to find the entry whose value is equal to 5. And in order to accomplish such a kind of task, we need a new function called "EQ" (shorthand for "Equals").

<b269>

This function takes two arguments, and returns "1" whenever they are equal. If they are NOT equal, it will return "0" instead.

And, do you remember the special algebraic rule I had introduced before? It goes like this: Whenever there is an underbar (_) in place of a function's argument, the previously added term will be transferred into it.

<b270>

With these constructs in mind, let me attach an additional column to the column of ID values. Every entry of this new column is filled with the expression "EQ(_,5)".

<b271>

Now, let me add these two columns together by means of a simple matrix multiplication (which is shown below).

<b272>

Do you see why the result is the way it is here? To clarify, I will show you the full breakdown of how the aforementioned combination of columns yielded "EQ(1,5)", "EQ(2,5)", "EQ(5,5)", and "EQ(4,5)". Take a look at the equations below:

<b273>

Here is what's going on.

What happens when we add the two columns together? Since the list of values in the first column is [1, 2, 5, 4] and the list of values in the second column is [EQ(_,5), EQ(_,5), EQ(_,5), EQ(_,5)], adding them up will produce a new column which is made up of: [1+EQ(_,5), 2+EQ(_,5), 5+EQ(_,5), 4+EQ(_,5)].

And, guess what? According to the special algebraic rule I have previously mentioned, this particular list of values will transform themselves into: [EQ(1,5), EQ(2,5), EQ(5,5), EQ(4,5)].

Now, it is time to evaluate the value of "EQ" in each of these entries. This final step is straightforward. Whenever the two arguments happen to be identical (as in the case of "EQ(5,5)"), the value becomes 1. Whenever the two arguments differ (as in the case of "EQ(1,5)", "EQ(2,5)", and "EQ(4,5)"), the value becomes 0.

<b274>

This is it. The resulting column values, [0, 0, 1, 0], is our "search result". We looked for the ID of 5, and the outcome signaled us that the 3rd row is where this ID is located (because the resulting value is 1 in the 3rd row and 0 everywhere else).

<b275>

With this result, we can then proceed to select our attacked frog and apply damage to it.