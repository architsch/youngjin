:d:On the hope of finding a better way to study math.
:k:Math, Mathematics, Math Education, Learning Technique, Study Tips
:l:2024-05-15

[A Layman's Bridge to Mathematics - Preface] May 15, 2024

Math is an important subject. We learn it in order to have a better understanding of the world around us. It is also useful for various applications such as those pertaining to economics, natural sciences, engineering, and many others.

The process of learning math, however, is oftentimes a bit of a pain in one's anatomical bottom. And the main reason why this is so is that the way in which math is being presented to the public is dominated by an enormous heap of dry rules and nitpicky technical details. To be fair, what sort of crackpot would be delighted to spend one's nightly leisure time watching a silent interplay of numbers, points, lines, and Greek letters on a sheet of paper?

A book which deals with mathematical ideas is typically filled up with a truckload of abstract symbols, as well as numerous theorems, examples, and proofs which thoroughly dissect their meanings. Such a comprehensive method of breaking down what is meant to be conveyed to the reader is, without a doubt, the most sincere and effective means of organizing a mathematical treatise.

Such a thorough manner of presentation, though, usually baffles those who are not professional mathematicians and thus do not possess enough patience to follow all the tasteless details. To the reader who is already endowed with the holy spirit of mathematics, those esoteric Greek letters do imply something enjoyable. To the layman, they do not mean anything.

Sadly, many of us often feel the necessity to spend some time studying mathematics for the sake of staying competent in our modern world, which is being governed by economists, business professionals, scientists, and engineers whose expertise heavily depends on the understanding of math. And this tendency seems to amplify itself the more our technology advances.

The problem lies on the fact that, while we do need to learn math, most of its study materials are so painfully unapproachable. And I myself wholeheartedly share this sentiment as well, even though I am an engineer with a 4-year university degree in engineering; it often requires me to load my brain with at least 100mg of caffeine in order to fool it into thinking that an algebraic formula is something interesting to look at.

So, how to fix this horrendous discrepancy between the necessity to learn math and the sheer lack of motivation to do so?

There indeed have been many attempts to deal with this problem, especially among educators, which involved storytelling (as in "Algebra, the Easy Way" by Douglas Downing), interactive visuals, games, and other fascinating experiments in the domain of mixed media.

Yet, for some reason, they do not seem as mainstream as they should be. Core math curriculums in the majority of public schools still heavily focus on teaching a set of formal proofs and problem-solving methodologies, most of which are obsessed rather too much with the technical side of mathematical reasoning than the divine inspiration behind it. As a result, most students get tired of the perennial influx of details before they grasp a chance to find passion in the subject.

In order to alleviate this shared sense of frustration, some educators choose to motivate their students by trying to convince them how useful math is. They tell their students that cool inventions such as airplanes, gaming PCs, Ferris wheels, and ice-pooping refrigerators are all being made by smart people who know all the fancy math and stuff, and that we, too, can do similar cool things by memorizing a bunch of theorems and knowing how to apply them.

Such a type of motivation, however, inadvertently degrades mathematics into some kind of "necessary evil" - a bucket of unappetizing veggies you must force yourself to swallow for the purpose of achieving some distant goal. This confounding gap between the ends and means is what often separates us from the pure joy of thinking mathematically; it is just not as directly rewarding as, say, playing video games.

Many (if not most) of the dedicated mathematicians who study math "just for fun" are not the ones who study it for the sake of utilizing it as a means of something else. They enjoy math as it is, just like many artists take pride in creating art for art's sake and nothing else. It is a "thing in itself", an inexplicable yet quantifiable sort of ghost which is everywhere but is never directly visible.

How to let ourselves grasp such a profound breed of enjoyment without too much hassle, then? A straightforward answer is to keep exposing ourselves to the world of mathematics as much as possible until a tickling moment of enlightenment reveals itself before the face of our subconscious, by means of reading textbooks, solving math problems, following lectures, and so on. This, however, requires us to spend too much time and energy to stay in focus. There must be a better way.

Let us start from common sense. The number one reason why mathematics is uninteresting to most of us is that it looks so detached from our everyday life. Most of us just do not "see" math in things we experience daily, although it really is everywhere from an abstract point of view (In a way, it is the highest form of philosophy - the purest essence of what we can think of and reason with). This is because math is abstract by nature; we can only induce its presence from the collective sum of our experiences.

<001>

The key is to narrow down the gap between our senses and their underlying abstract implications. And since we can only elaborate our own thoughts in terms of what we can directly perceive (because even purely abstract ideas require us to use symbols to express them), we must start with experiences which are familiar to us and then figure out how to let them reveal their own gateways to the beauty of mathematics.

(To be continued)







:d:About the nature of functions and the roles they play in mathematics.
:k:Function, Linear Operator, Linear Transformation, Functional Programming
:l:2024-05-18

[A Layman's Bridge to Mathematics - Part 1] May 18, 2024

First of all, let me suggest that food is our common denominator of interest. There are people who are not interested in sports, religions, politics, and the like, but there is absolutely no one who is not interested in eating at all (If there is one, that dude is dead).

And guess what? Since we like food, we must seek ways of obtaining it. Let's consider a biscuit as an example. One of the most obvious ways of acquiring a biscuit is to bake a piece of dough.

biscuit = bake(dough)

<002>

But in order to do that, we must first have a piece of dough in our hands. Let's make one, then, by mixing flour with water.

dough = mix(flour, water)

<003>

We can obtain flour by grinding wheat.

flour = grind(wheat)

<004>

To summarize, we can generate a biscuit by mixing ground wheat with water and baking it.

biscuit = bake(mix(grind(wheat), water))

<005>

I will explain the notations shown so far. "bake" is a function which takes dough as the input and produces a biscuit as the output, and "mix" is a function which takes flour and water as the input and produces dough as the output. "grind" is a function which takes wheat as the input as produces flour as the output. If you assemble these functions together in the right way, you will get a biscuit.

What is a "function", then? There are many ways of defining it, yet perhaps the most intuitive way is to consider a function as a little machine which has its own entrance and an exit. Through the entrance (aka "input port") it receives the ingredient, and through the exit (aka "output port") it spits out the result of manipulating the ingredient.

<006>

Whenever you choose to gather a multitude of such machines and compose them in order to produce the result you desire, you are building a factory where the individual workers collaborate with one another in a streamlined manner. The output of one worker could be handed over to another worker as the input, or multiple workers could be grabbing the same input and working on it concurrently so as to double the speed of production, and so on. There are so many possibilities here, and they can all be realized by joining functions with each other in creative ways. It all boils down to a network of input-output relations.

There is yet another way of defining what a function is, though. If you contemplate upon the meaning of a function in terms of what it does, you will soon come to the conclusion that a function is, on a purely conceptual level, just a bunch of connections between all of its possible inputs and their corresponding outputs.

<007>

Each connection (represented by an arrow) tells us which input values translate into which output values. For instance, the "bake" function can be identified as a set of connections between raw materials and their baked results.

<008>

What about a function which takes a pair of ingredients as the input instead of just a single ingredient? The "mix" function is a typical example of this; it "mixes" the two given ingredients and produces a mixture between the two as the output. In this case, we can consider each connection as one which maps a pair of input elements (instead of just a singular input) into their corresponding output.

<009>

This kind of representation is fine, for the purpose of providing us with a means of understanding what a function does. There is something quite annoying in this approach, however. As you may have noticed already, it is way too cumbersome to describe a function by mentioning every one of its input-output relations. For a very simple function it might be manageable, but for a fairly complex function it is prohibitively laborious.

What do we do, then? If taking all possible input-output relations into account proves itself to be too difficult, the other solution we ought to follow is to specify the general pattern in which inputs are being associated with their respective outputs. And in order to do that, we must establish a way to somehow "align" all the inputs (as well as outputs) in the form of an ordered sequence. This will give them a structure to fit in, thereby enabling us to render their behavior in terms of a generally applicable rule rather than an enormous collection of case-by-case scenarios.

<010>

Here, we are grouping all the possible inputs as an ordered sequence (represented by a long vertical arrow). Also, we are grouping all the possible outputs as yet another ordered sequence. The reason why we are doing this is to keep things organized.

As we ponder upon the very nature of what the so-called "inputs" and "outputs" really are, we quickly come to the realization that there is not really an intrinsic difference between things that are labeled as "inputs" and things that are labeled as "outputs"; an output of a function can also be an input of another function, and vice versa. Inputs and outputs are both "things" which, in the most unbiased mode of representation, can best be depicted as a set of points in empty space.

<011>

Oh, but here is where the trouble comes! Since there are so many things in our world to keep track of, we cannot just randomly plot them on a gigantic sheet of paper and try to make sense of them; such an undisciplined approach will make everything extremely confusing. What do we do, then? For sanity's sake, we organize them in some way or another. And one the most straightforward ways of organizing a bunch of things is to group them into categories.

<012>

For example, a variety of sandwiches, such as "chicken sandwich", "tuna sandwich", "meatball sandwich", "BLT sandwich", "PB&J sandwich", and the like, can all be grouped into the same category called "sandwich". The same logic applies to different breeds of a biological specie, different chemical elements in the periodic table, and so forth.

This sort of classification is still not enough, though. A category may turn out to be too broad in scope, that there are still way too many unorganized things lurking inside each category. This impels us to keep introducing new categories within our existing categories, thus giving birth to a taxonomical hierarchy.

<013>

As we do this, however, we begin to complicate things rather too much. It is usually not so high a virtue to have Russian dolls in one's faculty of reasoning, and it is important for one to admit that a more sustainable method of keeping things under control is to order them in the form of a sequence.

<014>

The long arrow shown here is a sequence, which bears a direction as well as the sense of alignment. Elements of this sequence either come before or after one another, depending on which of them are closer to the head of the arrow than others, etc. And the most quintessential advantage of doing it this way is that it lets us refer to things with numbers instead of arbitrary names.

<015>

Numbers reflect the concept of order very accurately. 1 comes after 0, 2 comes after 1, and 3 comes after 2. By comparing numerical values, we can immediately tell ourselves whether a thing comes before or after another thing. And as we figure out the order of things, we acquire a key to unlock the secret of parallelism. Here is an example:

<016>

We are looking at a function which is characterized by the equation: "output = input + 1". It means that the output of this function is always the result of incrementing the input by 1. We do not have to list all possible inputs and their corresponding outputs to fully define what the function does, since the equation alone reveals all the clues we need to derive the output from any given input.

The reason why such an abbreviation is feasible is that this function only deals with numerical entities (i.e. things which make up a sequence when they are put together). Since the input is a string of ordered things and the output is also a string of ordered things, we can consider the function as some kind of "string manipulator" - a special gadget which absorbs a string, distorts it (using mechanical instructions such as: "Cut it!", "Stretch it!", "Shrink it!", etc), and emits the result.

If the input were a mere assortment of random objects (like a bottle of jelly beans), it would have been extremely difficult to figure out what to do with them exactly. As we tie them up on a rope and treat the whole body as a single entity, we begin to let ourselves move all these individual pieces at once by simply pulling the rope. In mathematics, such a rope is called a "number line".

Aside from the ease of operation, the aforementioned mode of thinking also lets us plot the function's input-output relations in the form of a graph, like the one shown below:

<017>

Such is the power of expressing things in terms of numbers, hence the reason why they are so commonly used in mathematics. But of course, numbers themselves do not mean anything unless we specify the context in which they are being used. If I just say "Three!", it will hardly mean anything. If I say that I have three eggs, on the other hand, it will definitely mean something which can be pictured in the listener's mind.

(Will be continued in Part 2)







:d:About the meaning of numbers and how the idea of dimension gives them unique semantics.
:k:Number Theory, Dimension, Numerical Analysis, Linear Mapping, Quantitative Operators
:l:2024-05-21

[A Layman's Bridge to Mathematics - Part 2] May 21, 2024

(Continued from Part 1)

A number itself does not mean anything. A number which indicates a quantity of something we can see, hear, smell, or touch, on the other hand, does mean something.

In the previous chapter, I mentioned that a function is a machine which receives a thing called "input" and emits another thing called "output". A function does not necessarily receive everything we can possibly imagine, though; it is usually expected to accept only a certain category of things as inputs, and emit only a certain category of things as outputs.

It has also been noted that, for the purpose of simplicity, it is sensible to group things of interest in the form of an ordered sequence. This enables us to refer to them with numbers instead of arbitrary names.

The "bake" function is a machine which converts a piece of dough (input) into a biscuit (output). However, we are also aware that there are different types of dough from which a whole variety of baked products can arise, such as cookie dough, shortbread dough, scone dough, and so on. The "bake" function must take all these possibilities into account, since the word "bake" does not confine itself to the process of baking nothing but a tasteless hardtack.

<018>

And it is this moment at which we begin to realize the necessity of using numbers to represent our inputs and outputs. Individual terminologies such as "dough", "cookie dough", and the like, are not so easy to deal with because there is no fixed criterion under which they can be compared with each other in a consistent manner. The best we can do in such a circumstance is to merely list all possible scenarios.

Once we assign numerical values to the terms and line them up as a sequence, things start to become much more handy. Since they are quantities instead of just a bunch of qualitative indicators, we can now fully illustrate their input-output relations based upon a simple quantitative rule.

For example, suppose that different types of dough are denoted by single-digit numbers such as 0, 1, and 2, and that their baked results are denoted by double-digit numbers such as 10, 11, and 12, like the ones shown below.

<019>

We are assuming here that both the inputs and outputs of the "bake" function are numerical values. The benefit of doing this is that now we are able to use an algebraic pattern to describe what the function does.

<020>

We know that baking a piece of dough gives us a biscuit, baking a piece of cookie dough gives us a cookie, baking a piece of scone dough gives us a scone, and baking a piece of shortbread dough gives us a shortbread. According to the given set of equivalences, it is also perfectly valid to say that baking 0 gives us 10, baking 1 gives us 11, baking 2 gives us 12, and baking 3 gives us 13. Do you see the pattern here? It means that baking something is the same as increasing its value by 10.

<021>

Now we have it. "output = input + 10" is the only formula we need to be able to derive the output of the "bake" function from any given input. This is the power of representing things numerically; since quantitative operators such as addition (+), subtraction (-), multiplication (x), and division (/) are endowed with the ability to easily summarize the way in which one set of things can be mapped into with another set of things.

One major concern which may arise here, though, is that utilizing numbers in the context of baking is perhaps a bit too "hacky". As you may have noticed already, attaching arbitrary numbers to a bunch of seemingly unrelated objects such as "dough", "cookie", "shortbread", and so on, feels way too random when we think about it. Why should "cookie" always be identified by number 11? Why can't it be 42, 990, -83794, or 51.230774 instead?

This is probably one of the main reasons why so many people hate mathematics. Numbers, when their roles are not explained thoroughly enough, present themselves as nothing more than a library of obscure symbols. And what is unfortunate is that the origin of such evil can be attributed to hardcore mathematicians who are obsessed with brevity; their love for ultra-minimalism encourages them to oversimplify everything, including the very reason why we decided to use numbers in the first place (I mean, yes, mathematicians do indeed explain why they are using certain variables, symbols, and so forth, but such explanations are mostly concealed inside their bush of technical eloquence).

<022>

What we need is a down-to-earth illustration of what is going on, as well as why we need numbers for it. Once we are settled on that, we can then proceed to set up an agreeable standard as to the meaning of those numbers.

The biggest challenge is to establish an intuitively satisfying correlation between our practical interests and the way in which they are being represented. When we bake something, what we want to know is the type of the thing that we are baking, as well as the type of the thing that will result once baking is over. It is because we do not want to be ignorant of what we are putting into the oven and what we are getting out of it. We have an inherent desire to identify things we care, by means of names, numbers, or other identifiers.

And it is the heart of mathematical reasoning which guides us to the belief that numbers are the most preferred ones among such identifiers, due to the fact that their pre-established set of relations allow them to be mutually comparable. We cannot directly compare a biscuit with a cookie, but we can definitely compare the sweetness of a biscuit with the sweetness of a cookie because "sweetness" is something which can be characterized by a number (e.g. A small number refers to low sweetness, a large number refers to high sweetness, etc).

<023>

But then, of course, comparing sweetness is not the only option we have. We are also able to compare the size, weight, or color of the two desserts by means of numerical quantifiers. And it is necessary to realize that the same exact number (such as "3") can either mean sweetness, size, or weight, depending on what it is aiming to convey.

The problem is that it is not so easy to represent everything with just a single line of numbers. We need a multitude of them, each of which represents a separate dimension.

<024>

A dimension is a group of similar things which can be lined up as a sequence. The sweetness of a biscuit and the sweetness of a cookie are "similar" in the sense that they both belong to the same property called "sweetness", as well as that one of them either comes before or after the other in the spectrum of sweetness depending on what their values are. Therefore, they both belong to the same dimension which can be named "sweetness".

So now we have it. We are free to come up with any arbitrary dimensions, each of which corresponds to a category of things that are numerically comparable with one another.

We have an intuitive understanding that the "bake" function accepts a bakeable item as the input and returns a baked item as the output. What should be noted here is that there is a clear distinction between things that are eligible to be the input and things that are eligible to be the output; only those which are considered "bakeable" can possibly be the input of the function, and only those which are considered "baked" can possibly be the output of the function.

<025>

But again, we do not want to undertake the pain of having to specify every possible way in which a member of one group can be associated with a member of the other group. This can be avoided by introducing dimensions.

<026>

Here we have a dimension of bakeable objects, as well as a dimension of baked objects. Numbers in the bakeable-dimension are things which can be baked, and numbers in the baked-dimension are things which are the results of being baked.

Unfortunately, we are once again confronting the issue of semantics here. One can technically illustrate the aforementioned dimensions by saying, "10 is for biscuit! 11 is for cookie! 12 is for scone!" and so on, but such statements feel like they are out of nowhere. Hence, what does it imply when we compare one thing with another in this context? For example, if 11 denotes a cookie and 10 denotes a biscuit, does the fact that a cookie is 1 greater than a biscuit mean anything?

There would have not been such a problem of ambiguity if the dimensions referred to measurable quantities. So, let's rethink the nature of the "bake" function in terms of what can be measured.

Whenever we bake something, we are increasing the temperature of whatever is in the oven. So it seems that the input and output of the "bake" function could represent the initial and final temperatures of the oven's content, respectively. We can imagine that these two numbers both belong to the same dimension called "temperature".

<027>

This looks fair enough, yet we know that such a formulation does not render the full picture of what is really happening. The art of baking is not just about changing the temperature of the dough! There are so many other physicochemical processes going on inside the oven, besides the addition of thermal energy. It will be insincere for us to blatantly ignore these intricate details just for the sake of simplicity.

(Will be continued in Part 3)







:d:About multidimensional represenation of objects in our world.
:k:Multidimension, Vector Math, Mathematics, Casual Math, Vector Arithmetic, Linear Algebra
:l:2024-05-25

[A Layman's Bridge to Mathematics - Part 3] May 25, 2024

(Continued from Part 2)

Baking is a complex procedure. Inside the oven, we have a composition of various ingredients which chemically interact with one another in subtle ways as they get heated up. How quickly the temperature rises and falls, how long a certain degree of temperature persists, how humid the air is, as well as in what shape the dough is posing on the plate, all contribute to the characteristics of the resulting delicacy.

Trying to capture the intricacy of such a work of culinary art in the form of a mere conversion from one number to another does feel incomplete, doesn't it? Using a single numerical quantity to illustrate all the aforementioned details is indeed too much of an oversimplification.

What should we do, then? Fortunately, it is not hard to imagine a decent solution. If using a single number is not enough, just use more numbers to represent more complex things.

<028>

Here we have a piece of dough. Its temperature is 0, and its sweetness is 1. Let us take a look at another example.

<029>

This is a biscuit. Its temperature is 10 (Pretty high because it just came out of the oven), and its sweetness is 2.

As the two figures above demonstrate, both the dough and biscuit are characterized by two numbers instead of just one. One of them indicates the temperature, and the other one indicates the level of sweetness. We are dealing with multidimensional entities here.

So, if the dough is made up of two numbers and the biscuit is also made up of two numbers, how shall we then describe the nature of the baking process which supposedly transforms a piece of dough into a biscuit? Let us first take a quick look at what is going on here.

<030>

The "bake" function, unlike in the previous example where it was only responsible for converting one number to another, is now responsible for converting a pair of numbers (0,1) to another pair of numbers (10,2). This doesn't look like a simple one-to-one relation anymore, or does it?

Think of "temperature" as a number which belongs to one dimension, and "sweetness" as another number which belongs to another dimension. We can then model these two as points in two separate number lines, which leads us to imagine the dough as some kind of "joint" between its temperature and sweetness.

<031>

The same logic applies to the biscuit.

<032>

The dough has the right to identify itself as "dough" because it is associated with 0 in the temperature-dimension and 1 in the sweetness-dimension. The biscuit has the right to identify itself as "biscuit" because it is associated with 10 in the temperature-dimension and 2 in the sweetness-dimension.

The act of baking a piece of dough, then, can best be rendered as a transformation of the "dough" joint into the corresponding "biscuit" joint.

<033>

In general, what the "bake" function really does is highly intuitive; it simply maps a group of joints to another group of joints in a pairwise manner. In colloquial language, this can be worded as an act of simultaneously modifying both the temperature and sweetness of the given input.

<034>

A more consistent way of illustrating this phenomenon is to orient the two dimensions perpendicularly to each other, and use them as the axes of a two-dimensional space. Each object (i.e. anything that has both temperature and sweetness), then, can be drawn as a 2D point.

<035>

The chief benefit of such a representation is that you are now able to consider the "bake" function as a physical force which pushes a particle from one location to another. The particle's current location tells us its current state (i.e. temperature and sweetness), and the "bake" function can be imagined as some kind of "force field" which, like an ocean current, initiates a flow from one position to another.

Analogies aside, it is now time to explore other cases. We have seen that, in order to manufacture a dough, we have to mix flour with water. Such a process of mixture can be modeled as a function called "mix", which receives both flour and water as its inputs and produces a piece of dough as the output.

<036>

This one is slightly more complex than the "bake" function because it handles two inputs instead of just one. Such a level of detail is not so difficult to elaborate, though. Just like the dough and the biscuit could each be considered a combination between the two attributes called "temperature" and "sweetness", the input port of the "mix" function could as well be considered a combination between the two inputs called "flour" and "water".

<037>

But here is something much trickier. When we were dealing with only a piece of dough and a biscuit, we were only obliged to compare their temperature and sweetness for the sake of distinguishing one of them from the other. Since we now have two new types of objects called "flour" and "water", we must somehow figure out a way to distinguish them from the previous two.

For example, just by comparing temperature and sweetness, can we tell the difference between "flour" and "dough"? Somebody may argue that such a comparison is feasible because dough may be slightly sweeter than flour and so on, yet such case-by-case circumvention is not going to solve the ultimate cause of the problem.

As we attempt to compare more and more types of objects, we inevitably feel that we need to introduce more and more numbers (i.e. dimensions) to the scene for the purpose of classification.

In order to express the wetness of water, shall we create a new number called "moisture"? In order to express the hardness of a biscuit, shall we create a new number called "rigidity"? Also, in order to express the high separability of the individual grains of flour, shall we create a new number called "cohesiveness"? The list goes on.

How to mitigate such labor? For sure, we do not want to force every single object to carry a gigantic bag of properties in it. Having to deal with a plethora of dimensions is such a headache everyone wants to avoid.

<038>

The origin of the pain we are facing here is that, for instance, our faculty of senses does not allow the feeling of temperature and sweetness to be compared with each other in any rational manner. Aside from the realm of metaphors, it is not so universally agreeable to claim whether the hotness of a microwaved cheeseburger is supposed to be "greater" than the sweetness of a chocolate mousse cake; such a comparison is so irksomely subjective, that one has no choice but altogether abandon such a poetic kind of ponderance when it comes to scientific reasoning.

And due to their nature of mutual incomparability, temperature and sweetness are compelled to reside in two separate dimensions.

<039>

The incompatibility among different categories of sensation (e.g. brightness, loudness, smell, taste, pain, ecstasy, etc) is what necessitates us to keep adding more and more dimensions to our context of reason, thus plunging ourselves into the infernal crucible of numerical demons whose full-time job is to torment us forever with their contrived arithmetic puzzles.

We cannot escape this prison of complexity as long as we continue thinking solely in terms of dimensions. It confines our mind to the belief that, whenever we see something in nature which is measurable (i.e. can be specified as a quantity), we have no choice but simply come up with a new name for it. This sort of approach is unsustainable because it forces us to carry an ever-growing list of definitions on our backs.

In order to think outside of the box of dimensions, we must stop focusing too much on the nitty-gritty technical aspects of how we may distinguish one thing from another, and really try to rethink the way in which we define "things" in our universe.

There are innumerable things in our world which we can either observe or imagine. And we have an intuitive understanding that some of them are more generic than others.

When I see a collection of biscuits, I do recognize each one of them as a separate object. I may randomly pick three of them and give them unique names such as "biscuit A", "biscuit B", and "biscuit C".

<040>

Yet, I am also aware that these three biscuits are nothing more than particular instances of the same underlying idea called "biscuit". They may be distinct from one another in the sense that they belong to different positions and so forth, but they nevertheless share the same essence in the sense that they are all being referred to as "biscuits".

To conceptualize what is being expounded here, I will introduce two classes of things - namely, "universals" and "particulars".

<041>

A universal is a common characteristic which is being shared by multiple objects. A particular, on the other hand, is one of such objects. Biscuit A, biscuit B, and biscuit C are all particulars because they are instances of the same universal called "biscuit".

(Will be continued in Part 4)








:d:About ideas, their associations, and which conceptual insights we are able to derive from them.
:k:Math Education, Numbers, Numerical Methods, Universals, Particulars, Bertrand Russell, Analysis Of Mind, Discrete Math, Graph Theory, Network Theory
:l:2024-05-28

[A Layman's Bridge to Mathematics - Part 4] May 28, 2024

(Continued from Part 3)

There is no way for us to directly observe a universal, since it is not equal to any of its instances. The idea called "biscuit" is a universal because it is present in all of its corresponding particulars (i.e. actual biscuits which we are able to see, smell, touch, and eat), yet can never identify itself with any one of them specifically.

Dimensions, too, are universals because they are shared by multiple objects. "Temperature" is a universal because many things in our world possess their own degrees of temperature. "Sweetness", too, is a universal because there are many sweet things in our world, such as a piece of cake, a cookie, a candy, and so on, which have their own levels of sweetness.

<042>

And you know what? Numbers, too, are universals because they are being shared by multiple objects. A jar of 3 biscuits and a jar of 3 cookies are two separate instances, yet they both share the same universal called "3".

<043>

A temperature of degree 3 and a temperature of degree 4 both involve the same universal called "temperature". Here, however, we must behold that these two specific quantities are themselves universals, rather than particulars. The reason is that there could be multiple objects which have the same exact temperature.

<044>

Here is the main takeaway. A universal is generic in nature, but there are universals which are even more generic than other universals. The idea of temperature being equal to 3 (i.e. "temperature = 3") is generic in the sense that it can be shared by multiple objects whenever their temperatures are all measured to be 3 in magnitude, yet such an idea itself is still rather more specific than the more fundamental ones such as the idea of "temperature" and the idea of "3".

This sort of realization soon leads us to the conclusion that it is a bit pointless to try to divide everything into two disjoint classes called "universals" and "particulars". Some things may be more universal than others, and some things may be more particular than others, but does it suggest that we are absolutely required to establish a rigid boundary between these two concepts? Just like brightness and darkness, they may as well simply indicate the two opposing directions in a continuous spectrum.

<045>

Thus, it seems that one does not have to explicitly label every single thing as either "universal" or "particular", as these words merely represent the level of abstraction which is not strictly binary in nature.

The primary aim of what has been explained so far, is to get rid of our reliance on the concept called "dimension". As I have mentioned previously, a degree of temperature belongs to a dimension, a level of sweetness belongs to a dimension, and pretty much anything which can be denoted by a quantity belongs to a dimension. And the most annoying part of this is that, if we keep inventing new dimensions, we will soon be overwhelmed by the necessity to keep track of all of them.

And because of this reason, I will introduce here a more general definition of reality which transcends beyond a mere listing of numerical quantities.

Our universe is a vast network of ideas. Each idea is any "thing" we can think of in our mind; it could be a tangible object, a sensation, an impression, a word, or pretty much anything we are able to express in our language.

Ideas are either associated or not associated with each other, depending on whether conceiving one of them lets us conceive the other. In this model of the universe, each idea is rendered as a unique symbol (e.g. an alphabet) and each association between ideas is rendered as a line segment.

<046>

Each dimension is nothing more than a small subset of this network of ideas. The temperature-dimension, for example, is the set of all ideas which denote varying degrees of temperature, such as "temperature = 0", "temperature = 1", "temperature = 2", and etc.

<047>

A dimension is simply what we get by grouping a bunch of similar ideas together; it is by no means the most fundamental building block of our body of thoughts.

Here is a key observation which will support the statement I just made. As you can tell from the diagram above, the temperature-dimension is what you get by gathering all ideas which share the word "temperature" but do not share the same numerical value. In contrast, you can also imagine that it is equally feasible to gather all ideas which share the same numerical value (e.g. "3") but do not share the same word. An example of such a scenario is shown below.

<048>

A number which belongs to this alternative dimension tells us which characteristic of the object corresponds to the value of 3. Such an uncommon way of expression may hardly be useful for practical purposes, but it is nevertheless a perfect demonstration of the fact that a dimension is not a magical entity imbued with its own irreplicable qualities.

It feels like there is a clear difference between a dimension and a non-dimension, though. We are not likely to come up with a dimension just by picking a bunch of random ideas and putting them in a sequence, since the result is almost guaranteed to be meaningless. It is only when a sequence has at least one common idea (e.g. "temperature") as well as a range of numerical values to grant a sense of variability to such an idea, that it will qualify itself as a dimension.

<049>

Letting an object have its own inventory of traits, after all, is basically the same thing as associating the object with ideas which correspond to those traits.

Let us suppose for now that all biscuits in our hypothetical universe possess the same exact temperature and sweetness (which is obviously not true in the real world, but let us just pretend that it is so, for the sake of illustration). As long as such a supposition holds, the idea of "biscuit" should be directly associated with their common temperature as well as their common sweetness.

<050>

Individual biscuits, however, must have their own unique positions (unless we want all of them to be perfectly overlapping each other in one place). Therefore, each of the particular instances of "biscuit" will need to be directly associated with a position.

<051>

All biscuits have the temperature of 10 and sweetness of 2 because the idea of "biscuit", which simultaneously represents every single biscuit that can ever exist in this hypothetical universe, is directly associated with "temperature = 10" and "sweetness = 2".

On the other hand, specific instances of "biscuit" (such as "biscuit A", "biscuit B", and "biscuit C") have their own positions because they are directly associated with their corresponding positional quantities (i.e. "position = 0", "position = 2", and "position = 3").

While each particular biscuit can be thought of as carrying its own list of attributes such as "temperature", "sweetness", and "position", the question of whether an attribute shares the same exact value across all biscuits depends on the manner in which it is wired up in our grand network of ideas. A direct connection indicates something that varies across individuals, whereas an indirect connection indicates something that is common to all.

<052>

I have mentioned before that it is undesirable to try to represent an object with a gigantic list of numbers (dimensions) due to its inherent complexity. Now that we know that such numerical attributes are nothing more than associations among ideas, I guess we can all agree on the feasibility of fully describing an object not based upon a list of numbers, but based upon the way in which the object is associated with other ideas.

<053>

From a metaphorical perspective, I would say that each object is essentially a molecule made out of a set of conceptual atoms (i.e. ideas) and their chemical bonds. Once we figure out the chemistry of our mind, we will be able to design chemical equations to reflect the mechanics via which our thoughts combine, split, and rearrange themselves whenever they happen to be in proximity with one another.

Daydreamy tangent aside, here is another noteworthy advantage of structuring things as a network of ideas.

I have been naming things with well-understood words, such as "3", "temperature", "biscuit", and the like. However, each of these words is nothing more than a mere symbol, only meant to be a reference to the "real thing" which exists somewhere else. The idea of a biscuit is not the same thing as the word "biscuit", for instance, since we are able to think of a biscuit without spelling the word "biscuit" in our mind.

We do need some representation (i.e. image) of a biscuit to be able to imagine it, but the word "biscuit" is not the only symbol which can possibly serve the role of such a representation. One may as well use the term "solid-state complex carbohydrate" to indicate the same exact thing without incurring any logical contradiction.

Thus, we cannot assume that an idea must be endowed with a specific meaning just because it has a specific name. What gives meaning to an idea is the way in which it is being related to other ideas, not how it is being referenced in our language.

(Will be continued in Part 5)








:d:About the meaning of ideas in conceptual space.
:k:Philosophy of Psychology, Cognitive Science, Russell, Hume, Mathematics, Platonic Idea, Philosophy of Mind, Qualia
:l:2024-05-31

[A Layman's Bridge to Mathematics - Part 5] May 31, 2024

(Continued from Part 4)

Let us reiterate a bit.

Our world is filled with ideas, which are as numerous as stars in the night sky. Ideas are associated with one another, and associations are what gives meaning to the ideas.

Ideas and associations make up constellations in the heaven, which shine for eternity because they exist outside of space and time.

<054>

Each separate constellation is its own isolated chamber of vision. A spirit whose vision is stuck in one chamber is never able to see another, since there is no bridge to transfer the spirit's point of view from the one to the other. Our material universe, which we all share in common, is one big constellation in which everything we know happens. Ideas residing in other (disjoint) constellations can never be reached by our eyes, and thus lie beyond the boundary of human comprehension.

<055>

What grants identity to an idea is not its name, but the way in which it is being associated with other ideas; a name is just an artifact invented by humans for the purpose of communication. This brings us back to the prior illustration of the idea called "biscuit" and its characteristics.

How do we know that a biscuit is a biscuit? In real life, it will be quite tricky to provide an accurate answer because there are countless types of biscuits, many of which may exhibit a wide range of small differences. Inside the hypothetical universe I have previously shown, however, a biscuit is any object which has the temperature of 10 and sweetness of 2.

<056>

The key point of such a definition is that we identify the idea of biscuit with the word "biscuit" not because we have a special reason for choosing this specific word, but because this idea is associated with two other ideas which can be described as "temperature = 10" and "sweetness = 2".

Similarly, we know that an idea is an instance of biscuit (rather than the very idea of "biscuit" itself) not when its name suggests so, but when it is associated with two other ideas - one which could be identified as "biscuit", and the other one which could be identified as a particular position in space (e.g. "position = 0").

<057>

How do we know that the idea of "position = 0" denotes the idea of a spatial point located at 0, then? This one is fairly straightforward, too, since we know that any idea which is simultaneously associated with "position" and "0" is essentially what the idea of "position = 0" claims to be. No confusion here so far.

<058>

But hold on! Here is where things get really tricky.

How do we know that the idea of "position" itself refers to what we mean by "position"? The fact that it is associated with numerical values (e.g. 0, 1, 2, 3) is of no help here because there are tons of other ideas with the same exact kind of quantitative relations, such as "temperature", "sweetness" etc.

The thing is, we somehow know by heart that "position" is something which qualitatively differs from other equally sublime attributes such as "temperature" and "sweetness". Our faculty of sensation tells us that a biscuit's position is of a fundamentally separate nature from its temperature or sweetness.

Yet, as we ponder upon the ways in which some of the other ideas are being defined, we begin to notice a morsel of clue lurking in the back of our minds.

For example, how does the idea of "3" justify its own presence as number 3, and not 1, 2, or some other number? There could be a multitude of alternative definitions, but the most reasonable one is to define the idea of "3" as one which happens to associate itself with every instance of number 3.

There is the idea of "3 biscuits", as well as the idea of "3 pieces of dough". There is also the idea of "3 cookies", "3 houses", "3 people", "length of 3 meters", "duration of 3 seconds", and so on. All these ideas bear the sense of 3-ness in them, and if there is one idea with which all of them are associated, we can conclude that it must be the idea of "3".

<059>

Similarly, we may define the idea of "position" as the one with which all position-bearing ideas are associated - that is, ones that are being worded as "position = 0", "position = 1", "position = 2", etc.

Such a line of argument appears to be circular, though. If "position" is defined in terms of its relations to "position = N" (for any arbitrary number N) and "position = N" is defined in terms of its relations to "position", all we are left with is a mere conceptual short circuit, contrived to bypass the logical dead end.

<060>

Therefore, we need an external piece of puzzle to grasp the essence of these seemingly inexplicable ideas (e.g. "position", "temperature", "sweetness").

The first barrier we ought to dismantle is the underlying assumption that ideas which pertain to tangible objects are any more self-explanatory than those which are deemed abstract.

For instance, we all know that "position" is a highly generic concept, and thus cannot quite explain its own nature except by means of real-life examples, right? We need at least some diagrams, written symbols, or anything which can directly appeal to our senses, in order to feel the existence of such an abstract entity.

In contrast, let us imagine that there is a biscuit sitting on top of a table. You and I can clearly see it, touch it, smell it, and eat it. We decided to call this particular object "biscuit A".

<061>

Since we can directly perceive this object, it feels like we do not need any more insight to understand it further. This particular biscuit is simply what our senses tell it is, isn't it? What else do we even need to know more about it?

The problem is that such an implicit delegation of reason is just as insincere as the claim that the idea of "position" is simply what its real-life examples show it is. If we define "biscuit A" based on the way it speaks to our senses, and if we also define "position" based on the way it speaks to our senses (by means of examples), can we really assure that there is a fundamental difference between "biscuit A" and "position", in regard to the certainty of their existence?

One might insist that the object called "biscuit A" must obviously be way more self-explanatory than, say, the idea of "position", due to the fact that there are innumerable instances of position in real life (which makes "position" more general than specific) whereas there is no instance of "biscuit A" other than itself (which makes "biscuit A" more specific than general).

<062>

However, it is also feasible to say that such a statement is not necessarily true because we may as well think of multiple instances with which "biscuit A" is associated, such as a photo taken from "biscuit A", a speech witnessing the presence of "biscuit A", a written letter about "biscuit A", a mirror image of "biscuit A", and so forth.

<063>

One may say that taking these examples as direct instances of "biscuit A" is pure nonsense because they are merely secondary sources and can never be as vivid as an actual sight of "biscuit A" which is something only our bare eyes are capable of witnessing. Such an assertion, however, is groundless from a cognitive point of view because no observation, regardless of how lucid it might be, can be a decisive evidence of the existence of "biscuit A". What we think we just saw with our bare eyes could have been a deliberate illusion, you know.

And since no observation can possibly provide us with the utmost degree of confidence as to the truthfulness of whichever object we are dealing with, the best methodology we may safely employ is to assume that the truth lies somewhere at the center (i.e. average) of our cloud of observations. Such is the virtue of statistics, and its empirical worldview justifies itself not based on some kind of tautology, but on our collective faith that it is "least biased".

Let me just suppose here that there are two universes. One is simply the universe I have hitherto been talking about, and the other one is what I would refer to as the "anti-universe".

In our regular universe, a biscuit is something real and can be perceived directly; it is as close to the threshold of our sensation as it can manage itself to be. "Position", on the other hand, is a general concept and is therefore never visible to us.

<064>

In the anti-universe, everything is reversed. People who dwell in this "upside-down" world never recognize a biscuit as something perceivable; to them, a particular biscuit such as "biscuit A" is the most abstract idea one can ever come up with.

In contrast, the idea of "position" is recognized as a tangible object here. It is an indestructible solid cube occupying the center of everybody's field of view, and is always available to be seen, touched, and even licked (It tastes like a canned cherry).

<065>

How, then, will we ever be able to convince the citizens of the anti-universe that "position" is indisputably abstract and "biscuit A" is indisputably tangible, other than by the evidence of our own cognitive tendency?

(Will be continued in Part 6)








:d:About pragmatism in mathematical ideas.
:k:Philosophy of Math, Analysis of Mind, Bertrand Russell, David Hume, Math Education
:l:2024-06-03

[A Layman's Bridge to Mathematics - Part 6] June 3, 2024

(Continued from Part 5)

Therefore, the more I look inside the hidden intricacies of ideas and their associations, as well as the sheer impossibility of discovering the ultimate root of their definitions, the more I cannot help myself concluding that the world of ideas is one vastly intertwined fabric of mutual dependencies which must be regarded as it is, never meant to be decomposed into clean pieces.

<066>

And it is a true disappointment to be witnessing such a rigid intellectual bedrock, for it means that one's last remaining path of investigative freedom is faith alone, and that none of the cunning bits of sophistry will replace it except in the ivory tower of academic word play and metaphysical masturbation.

So, how to overcome this major obstacle? I would say that there are two major solutions.

One is to keep identifying all sorts of ideas and associations in the most strictly logical manner as possible, by using fancy math equations and stuff. Once we choose this hardcore route, we will have to carefully dig through the labyrinth of details and always take caution not to let them contradict one another.

Building rules upon rules and theorems upon theorems, we may eventually acquire a faint glimpse to the overall landscape of our universe. We may even manage to thoroughly dissect a small region of ideas in the midst of the sea of chaos, render the full anatomy of it, and use it as a stepping stone towards a better understanding of the subject. This, however, is a wishful daydream. The exploration might as well lose its momentum at some point, leaving us confounded by the snowballing body of complexity.

The other solution is to simply give up the notion that we are ever going to figure out the "absolute truth" of the subject, and simply resort back to the primordial mindset of picking and choosing what works for us from a practical standpoint.

The reason why I started mentioning ideas, associations, and their vast relational assembly in the first place, was to come up with an easier way of depicting various events in life.

For example, the "bake" function was originally defined as a process of receiving a collection of numbers (i.e. a piece of dough) and turning it into another collection of numbers (i.e. a biscuit). This sort of approach was deemed too notationally verbose, so I came up with a new conceptual model which characterized such parameters in terms of ideas and their associations.

<053>

The thing is, if this graph-based worldview introduces more bits of complexity to our faculty of reasoning than the ones it promises to get rid of, there is no reason for us to keep using it. The whole purpose of devising such a theoretical construct was to help us develop a better understanding of what really happens when we bake something. Why should we preserve such a construct as it is, then, if it fails to serve its designated role?

If one model does not work, the most sensible alternative is to replace it with another one which solves the problem more effectively.

The goal is quite obvious here. We want to build a new model which lightens the weight of our mental labor. Such a model does not need to be completely different from the original, though; we only need to "tune" the existing thing in an intuitively satisfying way by replacing some of its convoluted parts with simpler analogues.

A gigantic web of associations among ideas, for instance, is too confusing. So let us just entirely exclude the concept of association from our system.

<067>

Also, there is no compelling reason for considering some of the ideas as "abstract". As I have demonstrated before, the very notion of abstraction itself is pretty darn subjective anyways, as it largely depends on our cognitive preference.

So, why not just depict every single idea as a tangible object - that is, a solid particle with its own mass, volume, and a location in physical space? It doesn't matter whether an idea is supposedly abstract, vague, or invisible. All ideas, both universal and particular, concrete and abstract, dim and vivid, can neatly be depicted as rigid bodies following Newton's laws of motion.

<068>

In this brand new model of the universe, everything appeals to our senses in the most blatantly direct manner as possible. Numbers are for counting things, and a quantitative measure (e.g. "temperature", "sweetness", "position", etc) is simply the number of copies of its corresponding particle. The idea of "temperature = 3", for example, can be characterized by the bondage of 3 temperature particles.

<069>

A piece of dough, then, is nothing more than a single sweetness particle, and a biscuit is the composition between 10 temperature particles and 2 sweetness particles.

<070>

The "bake" function is a particle-processing machine. Whenever it takes 1 sweetness particle (aka "dough") as the input, it returns a molecule of 10 temperature particles and 2 sweetness particles (aka "biscuit") as the output. All it does is to add 10 temperature particles and 1 sweetness particle to whichever raw material it happens to bake.

<071>

Algebraically, such a process is simply described as:

bake(input) = input + 10 temperature + 1 sweetness

The "temperature" variable represents a temperature particle, and its multiplier (10) indicates how many of its copies are being added to the input. Likewise, the "sweetness" variable represents a sweetness particle, and its multiplier (1) indicates how many of its copies are being added to the input.

We know that, when we bake a piece of dough, we obtain a biscuit.

biscuit = bake(dough)

<002>

A piece of dough is the same thing as a single sweetness particle. That is,

dough = 1 sweetness

Therefore, baking a piece of dough can be characterized as:

bake(dough) = bake(1 sweetness) = 1 sweetness + 10 temperature + 1 sweetness = 10 temperature + 2 sweetness

Since a biscuit is just a combination between 10 temperature particles and 2 sweetness particles,

biscuit = 10 temperature + 2 sweetness

We are able to conclude that the "bake" function's formula perfectly matches our expectation.

This sort of logic, with the aid of intuition, easily expands itself beyond the case of dough and biscuit. Our common sense tells us that the process of heating an object is the same thing as adding an extra temperature particle to it, for instance.

heat(input) = input + 1 temperature

<072>

We also know by intuition that the process of cooling is basically the opposite of heating - that is, subtracting a temperature particle from the given object.

cool(input) = input - 1 temperature

<073>

What about moving an object? Just like the object's current degree of temperature can be represented by its number of temperature particles, its current position can be represented by its number of position particles. For example, if the position is 1, there will be 1 position particle, and if the position is 2, there will be 2 position particles, and so on. Thus, the process of "moving forward" is the same thing as adding a position particle, and the process of "moving backward" is the same thing as subtracting a position particle.

moveForward(input) = input + 1 position

<074>

moveBackward(input) = input - 1 position

<075>

For example, you can move your biscuit forward in space by giving it a position particle.

moveForward(biscuit) = biscuit + 1 position

<076>

Does your biscuit have no position particle at all, but you still want to move it backward anyways? Add an anti-position particle, then (denoted by "-position" instead of "+position").

moveBackward(biscuit) = biscuit + 1 (-position) = biscuit - 1 position

<077>

A biscuit with 0 position particle is a biscuit located at position 0, and a biscuit which has 1 position particle is a biscuit located at position 1. Likewise, a biscuit which has -1 position particle (i.e. "1 anti-position particle") is a biscuit located at position -1.

The concept is pretty simple. Every attribute of an object (e.g. "temperature", "sweetness", or "position") is a distinct particle type, and the attribute's quantity is determined by the number of particles which belong to that specific type.

In this new worldview, a two-dimensional point in space can be expressed as a composition of X particles and Y particles. The number of X particles indicates the x-coordinate of the point, and the number of Y particles indicates the y-coordinate of the point. You can change the location of this point by changing the number of its X and Y particles (X for horizontal movement, Y for vertical movement).

<078>

When a particle meets an anti-particle of the same type, they both disappear. This is because two opposing forces cancel each other out.

<079>

The benefit of imagining things based upon a mechanical analogy like this, is that most of the details (e.g. ideas and their associations) are implicitly being handled by its underlying physics.

(Will be continued in Part 7)







:d:A factory analogy of mathematical objects, and the problem of giving a unique identity to each one of them.
:k:Signal Processing, Discrete Time Signal Processing, Z Transform, Difference Equation, Transfer Function, Mathematical Analogy, Easy Math
:l:2024-06-07

[A Layman's Bridge to Mathematics - Part 7] June 7, 2024

(Continued from Part 6)

It has been supposed that a biscuit is a combination between 10 temperature particles and 2 sweetness particles.

biscuit = 10 temperature + 2 sweetness

Here is something tricky, though. What if there are two biscuits instead of one? Shall we just multiply the biscuit by 2, so as to express the fact that there are two copies of it? But if we do that, the numbers will soon show us that the result is a mixture of temperature/sweetness particles that are twice as many as before, which is something unknown to us.

2 biscuit = 2 (10 temperature + 2 sweetness) = 20 temperature + 4 sweetness

<080>

When someone says, "There are two biscuits", one does not simply mean that the ingredients of these two biscuits are put together at the same location. What the person really means is that there are two whole separate biscuits, existing independently from each other.

Therefore, we need some way of distinguishing one biscuit from the other whenever we are dealing with two biscuits instead of just one. How shall we accomplish such a goal?

One thing that is for sure is that each biscuit must possess its own identity (aka "ID") in order to be able to distinguish itself from others. If we suppose that there are two special variables called "ID1" and "ID2", for instance, we will be able to use them to uniquely identify two biscuits.

Assignment of an identifier can be done by means of multiplication. If you have a biscuit, you can assign the identifier "ID1" to it by simply multiplying it by ID1. Likewise, you can assign the identifier "ID2" to another biscuit by multiplying it by ID2. Once you do that, you can safely combine the two results together and still ensure that these two biscuits are separate objects, as well as that they are just being "placed together" instead of being merged into one grotesque sort of concoction.

biscuit ID1 + biscuit ID2

<081>

As the formula above tells us, each identifier prevents its respective biscuit from being merged with the other, due to the fact that there is no way for us to simplify the expression "biscuit ID1 + biscuit ID2" to a single term. Since ID1 and ID2 are variables instead of plain numbers, we are unable to fuse the term "biscuit ID1" and the term "biscuit ID2" together into a single numerical value.

This works well so far, but here is a problem of scalability. If I have 3 biscuits instead of just 2, what should I do to keep these 3 things separate from one another instead of letting them fuse into one?

Indeed, a straightforward solution is to introduce the third identifier called "ID3" and proceed to assign it to the third biscuit via multiplication.

biscuit ID1 + biscuit ID2 + biscuit ID3

<082>

As you may have noticed, however, it implies that we will be obliged to come up with a brand new identifier whenever we decide to add yet another biscuit to the formula.

What if we want the fourth biscuit? Oh, we will need "ID4" to make sure that this fourth biscuit is different from the previous three. What if we want the fifth biscuit? Oh, of course, we will need "ID5" to make sure that this fifth biscuit is different from the previous four. And so on.

<083>

This is obviously unsustainable. If we need a truckload of identifiers just to represent a truckload of biscuits, there must be something wrong here.

Fortunately, there is one little trick you can use to solve such a problem. Suppose that there is a variable called "ID" which can be used as a unique identifier. One important point to realize is that, since "ID" is just an arbitrary variable, we can multiply it by itself (i.e. ID ID) to create a whole new unique identifier. This method of generating identifiers may continue on and on, like the examples shown below.

ID1 = ID
ID2 = ID ID
ID3 = ID ID ID

The first identifier is the result of multiplying ID once, the second identifier is the result of multiplying ID twice, and so on, which means that the n-th identifier is the same thing as multiplying ID n times. If we use this pattern to keep three biscuits separate from one another, it will look like:

biscuit ID + biscuit ID ID + biscuit ID ID ID

Since repeating the same multiplication is basically what exponentiation is in mathematics, the expression above will be simplified as:

biscuit ID + biscuit ID + biscuit ID

<084>

The first identifier is ID itself, the second identifier is ID-squared, and the third identifier is ID-cubed.

So, if you ask the first biscuit, "Show me your identification card, please!", he will show you a thin stick that is ID-meters long. If you ask the second biscuit the same question, this second gentleman will show you a square sheet of paper with sides that are ID-meters long. If you ask the third, he will show you a cube with edges that are ID-meters long. This is how you allocate separate identities to these 3 biscuits; each of them is identified by the number of dimensions of his ID card.

The role of ID, ID, and ID is to make their corresponding terms (biscuits) unique, so that they will not mix with each other. If you try expanding the formula like the following:

biscuit ID + biscuit ID + biscuit ID = (10 temperature + 2 sweetness) ID + (10 temperature + 2 sweetness) ID + (10 temperature + 2 sweetness) ID = 10 temperature ID + 2 sweetness ID + 10 temperature ID + 2 sweetness ID + 10 temperature ID + 2 sweetness ID

<085>

You can clearly see here that the temperature particles of the first biscuit are separate from those of the second and third, as well as that the sweetness particles of the first biscuit are separate from those of the second and third. This is because every single particle of a biscuit is endowed with the biscuit's own identity.

What if you want to create a new biscuit? This, too, can be accomplished fairly easily based upon a simple algebraic trick. Since each biscuit's unique identity is solely determined by the number of times it has been multiplied by the variable called "ID", all you have to do to introduce a new biscuit to the scene consists of two steps: (1) Multiply the whole algebraic expression by ID, and (2) Add "biscuit ID" to the resulting expression.

If we suppose that there is a function called "addBiscuit" which carries out the procedure I just mentioned, it will look like the following:

addBiscuit(originalBiscuits) = biscuit ID + originalBiscuits ID

<086>

The "addBiscuit" function receives the original list of biscuits (i.e. "originalBiscuits") as the input and produces the augmented list of biscuits as the output. If we originally had only 2 biscuits, "originalBiscuits" would be expressed as:

originalBiscuits = biscuit ID + biscuit ID

The output, then, would be:

addBiscuit(originalBiscuits) = biscuit ID + (biscuit ID + biscuit ID) ID = biscuit ID + biscuit ID + biscuit ID

<087>

This is exactly as expected. Since we added a biscuit to the original list of 2 biscuits, we now have 3 biscuits which are being identified by ID, ID, and ID.

The converse process is equally feasible. Just like we are allowed to add a biscuit to the group, we must also be allowed to subtract an existing biscuit from the group. Imagine that there is yet another function called "subtractBiscuit" which does exactly what the "addBiscuit" function does in reverse (because subtracting is the opposite process of adding). That is, whenever it receives an input, it: (1) Subtracts "biscuit ID" from the given algebraic expression, and (2) Divides the resulting expression by ID.

subtractBiscuit(originalBiscuits) = (originalBiscuits - biscuit ID) / ID

<088>

The "subtractBiscuit" function subtracts "biscuit ID" instead of adding it because subtraction is the inverse of addition, and divides ID instead of multiplying it because division is the inverse of multiplication. Also, this function runs the two arithmetic steps in the reverse order with respect to that of the "addBiscuit" function.

So, if we suppose that there were originally 3 biscuits,

originalBiscuits = biscuit ID + biscuit ID + biscuit ID

Subtracting a biscuit from it will exhibit the result below:

subtractBiscuit(originalBiscuits) = (biscuit ID + biscuit ID + biscuit ID - biscuit ID) / ID = (biscuit ID + biscuit ID) / ID = biscuit ID + biscuit ID

<089>

This means that subtracting a biscuit from the original list of 3 biscuits will give us an updated list which only contains 2 biscuits (i.e. One with the identifier "ID", and the other one with the identifier "ID").

A handy way to picture in our minds what is really going on is to imagine that we are inside a factory's assembly line, looking at a conveyor belt which carries a queue of biscuits. The conveyor belt consists of a number of slots, each of which can be occupied by a biscuit.

<090>

If we assume that the first slot is identified by "ID", the second slot is identified by "ID", the third slot is identified by "ID", and so forth, we will be able to declare that each of these identifiers essentially refers to the position of the slot with respect to the end of the belt.

<091>

(Will be continued in Part 8)







:d:Functional Programming, List Processing, and the usage of polynomials and their algebraic operations for manipulating list data.
:k:List Processing, LISP, Polynomials, Practical Math, Industrial Engineering, Math Education, Z Transform, Difference Equations
:l:2024-06-10

[A Layman's Bridge to Mathematics - Part 8] June 10, 2024

(Continued from Part 7)

Let us imagine that we are in a biscuit factory, staring at a conveyor belt which has biscuits on it.

The belt does not have to be fully loaded with biscuits, however. It may as well have empty slots, as well as those that are occupied by other types of objects such as cookies, tarts, or homemade pot pies.

Each slot carries its own identifier such as ID, ID, or ID, and we have the right to assign anything to it, including emptiness itself (which is represented by 0). An example is shown below.

conveyorBelt = biscuit ID + dough ID

<092>

This belt has a biscuit on the second slot (ID) and a piece of dough on the third slot (ID). The first slot (ID) is empty (= 0), so it does not even appear in the formula.

For simplicity's sake, though, I will ignore the sheer variety of stuff with which the conveyor belt could be filled up for now and solely focus on its rudimentary mechanics. Suppose, for a moment, that we only have a biscuit on the second slot (ID) and absolutely nothing else.

conveyorBelt = biscuit ID

<093>

What is going to happen if we multiply the formula by ID? Assuming you know how to multiply, I would say that the biscuit's identifier (ID) will turn itself into ID because ID x ID = ID. This is the same thing as pushing the biscuit to the back by one slot.

pushBack(biscuit ID) = (biscuit ID) ID = biscuit ID

<094>

The inverse operation is also possible. You can push the biscuit to the front by dividing the formula by ID instead of multiplying.

pushFront(biscuit ID) = (biscuit ID) / ID = biscuit ID

<095>

The ability to push things in both directions is not limited to the case of a single biscuit. If there are multiple objects on the conveyor belt, multiplication by ID will push all of them simultaneously to the back. Similarly, division by ID will push all of them simultaneously to the front.

Let us revisit the previous two functions called "addBiscuit" and "subtractBiscuit". In these two functions, we were dealing with a bunch of biscuits and their distinct identifiers (e.g. ID, ID, ID).

In order to add a new biscuit to the belt, what should we do? If the frontmost slot (ID) is empty, we can simply add "biscuit ID" to the formula to fill it up with a biscuit. If the slot is not empty, however, adding "biscuit ID" to the formula without any prior action will basically "mix" the new biscuit with the existing object, subsequently generating a weird mixture.

Therefore, we must first push everything to the back in order to make room for the new biscuit. Once we do that, we will be able to safely add "biscuit ID" to the conveyor belt without worrying about accidentally mixing things up.

addBiscuit(conveyorBelt) = biscuit ID + conveyorBelt ID = biscuit ID + pushBack(conveyorBelt)

<096>

What about subtracting a biscuit? If we presume that the frontmost slot is already occupied by a biscuit, we will be able to tell that subtracting "biscuit ID" from the formula will neatly get rid of an existing biscuit from the conveyor belt. Then, since somebody might want to remove yet another biscuit later on, we should probably push everything to the front so as to enable subsequent acts of subtraction.

subtractBiscuit(conveyorBelt) = (conveyorBelt - biscuit ID) / ID = pushFront(conveyorBelt - biscuit ID)

<097>

The notion that we ought to "push things to the front after removing the frontmost element" is not just something I contrived out of nowhere. When you grab a gun (semiautomatic pistol) and fire it once, what does it do? It first destroys the uppermost bullet by hitting its ass with a rigid rod, and then pushes the rest of the bullets upward to fill the gap. Think of the "subtractBiscuit" function as the act of firing a biscuit-gun.

The real problem, though, resides in the fact that I am making a bold assumption here which may not always be the case.

If the belt's frontmost slot were occupied by a biscuit, we would definitely be able to use the "subtractBiscuit" function without any trouble. If the slot were either empty or occupied by something else, however, we would be in trouble because applying the "subtractBiscuit" function to such a case is an equivalent of merging an anti-biscuit (i.e. "-biscuit") with whatever is sitting on the frontmost slot.

<098>

In order to prevent such a calamity, we must check the current status of the conveyor belt before fiddling with it. This "checking" part, when correctly implemented, will prevent us from facing undesired consequences.

How shall we do that, in the case of the "subtractBiscuit" function? The first step is to decide which condition we ought to check, and the second step is to decide what to do when such a condition is either satisfied or dissatisfied.

In other words, we need a conditional statement in our function.

<099>

A conditional statement allows us to choose which of the two pathways we must follow. If the given condition is satisfied, we will follow the "YES" path. If not, we will follow the "NO" path.

In our "subtractBiscuit" function, the condition we want to check is whether the conveyor belt's frontmost slot has a biscuit or not. Algebraically, it is the same thing as saying whether the formula contains the "biscuit ID" term or not.

If this condition is met, we will proceed to remove "biscuit ID" from the belt. This is our "YES" path.

Otherwise, we must leave the belt as it is without changing anything. This is our "NO" path.

CONDITION: Does conveyorBelt contain "biscuit ID"?
IF "YES": subtractBiscuit(conveyorBelt) = pushFront(conveyorBelt - biscuit ID)
IF "NO": subtractBiscuit(conveyorBelt) = conveyorBelt

<100>

What shall we do if the conveyor belt's frontmost slot is occupied by a cookie instead of a biscuit? The answer is pretty straightforward because we now know what the condition is. The formula does not have "biscuit ID" in it, so we will do nothing and simply return the original conveyor belt.

conveyorBelt = cookie ID + biscuit ID
subtractBiscuit(conveyorBelt) = conveyorBelt

<101>

What shall we do if the conveyor belt's frontmost slot is occupied by a biscuit? Since the formula does indeed have "biscuit ID" in it, we will continue on with our usual biscuit removal process.

conveyorBelt = biscuit ID + cookie ID
subtractBiscuit(conveyorBelt) = pushFront(conveyorBelt - biscuit ID)

<102>

So far, quite a number of things have been demonstrated. We now have a method of keeping multiple objects together in one place (i.e. conveyor belt), as well as a method of adding, removing, and modifying them in a selective fashion, with the help of conditional statements such as: "Is the fourth slot of this conveyor belt empty?".

All these techniques, with a bit of additional insight, allow us to build any sophisticated system we may dare to imagine.

In order to prove such a claim, let me suppose that our conveyor belt is infinite in length - that is, its number of slots is unbounded. In the middle, we have a slot which has "1" as its identifier (because it is the 0-th power of ID, which equals 1). On the right side, we have slots identified by positive powers of ID. On the left side, we have slots identified by negative powers of ID.

conveyorBelt = ... + (?)ID + (?)ID + (?)ID + (?) + (?)ID + (?)ID + (?)ID + ...

<103>

And let me also suppose that there is a function called "addBiscuitAt" which adds a biscuit not necessarily at the frontmost slot of the conveyor belt, but at any given slot (i.e. the one whose identifier is "slotID").

addBiscuitAt(conveyorBelt, slotID) = (biscuit + conveyorBelt / slotID) slotID

The way this function operates may look a bit strange, but it is not too hard to comprehend. Think of it as a machine which sits at the center of the conveyor belt. Dividing the formula by "slotID" pushes all the slots in the way in which it will bring the designated slot to the center. The machine, then, adds a biscuit, and then multiplies the formula by "slotID" to push all the slots back to their original locations.

This 3-step procedure, as a result, modifies only the given slot (i.e. the one whose position is "slotID") and leaves all other slots untouched.

An example usage of this function is displayed below.

conveyorBelt = biscuit ID + biscuit ID
addBiscuitAt(conveyorBelt, ID) = (biscuit + conveyorBelt / ID) ID

<104>

In addition, there may also be myriads of other functions which are designed to access and/or modify any arbitrary slots in this infinite conveyor belt, such as "subtractBiscuitAt(...)", "moveBiscuitTo(...)", and so on. With the help of such functions, we will be able to do anything a computer can do. Why? Because what I just portrayed here is essentially what people call "Turing Machine".

The world of math is one vast imaginary computer. Our conveyor belt is the computer's memory, and our functions are its machine instructions (aka "programs").

(Will be continued in Part 9)








:d:On intuitive understanding of addition, multiplication, and other basic arithmetic operations.
:k:Basic Math, K12 Math, Math Education, Visual Math, Philosophy of Mathematics, Mathematical Philosophy, Physical Math, Mechanical Math
:l:2024-06-13

[A Layman's Bridge to Mathematics - Part 9] June 13, 2024

(Continued from Part 8)

All right, enough with the conveyor belt!

For the sake of not plunging too deeply into technical details, I will put a pause on the ongoing topic for now and go through the fundamentals.

It has been mentioned that our world is made out of various things, and that such things can be expressed in terms of particles. Any object can be considered a combination of one or more particles. A biscuit, for instance, has been defined as the combination between 2 sweetness particles and 10 temperature particles.

<105>

However, I have not explained yet how particles really interact with one another. In order to clarify some of the points which may have been seemingly vague, I will first start with "pure" particles - that is, particles which have no type at all.

Both sweetness and temperature particles are "impure" in the sense that they represent characteristics of real (tangible) objects. Pure particles, on the other hand, are "pure" in the sense that they are the most basic units of existence, devoid of any extra meaning.

<106>

Let us forget about biscuits and cookies for a moment, and start thinking in terms of pure particles and their elementary mechanics.

Particles are like tiny little bubbles. Some of them have names written on their faces, but such additional ornaments make them impure. Pure particles don't even have names; they are completely anonymous, just like innumerable little bubbles hovering in midair.

Imagine that a body of 2 particles and a body of 3 particles charge straight toward each other and collide in the middle. What is going to happen? Since particles tend to stick together when forced to be in one place, they bond to form a singular body of 5 particles. This is what it means to "add" two things.

2 + 3 = 5

<107>

What if the body of 2 particles were made of anti-particles (denoted by "-") instead of regular ones? In this case, I would say that they are "impure" because they are imbued with the meaning of negation (-). They possess the ability of "cancelling out" their positive counterparts. So when a particle meets its opposing anti-particle, they combine to form 0, annihilating each other completely.

This means that, when 2 anti-particles collide with 3 regular particles, 2 of their opposing pairs will cancel each other out and disappear completely, leaving only 1 regular particle to remain. Such an event is what we call "subtraction"; we are subtracting 2 from 3 here.

(-2) + 3 = (-1+1) + (-1+1) + 1 = 1

<108>

The main takeaway is that, whenever we add two things, they stick together and form a single rigid body. We do not "mix" them in any way; we just put them together, so as to ensure that they are touching each other.

What happens when we multiply two things? A good way of understanding the nature of multiplication is to think of it as a process of "planting" one thing upon the soil of the other. You can plant a flower in two pots, and expect that these two pots will each be occupied by a flower later on, resulting in two flower-bearing pots in total. Such is the result of multiplying a flower by two pots.

Similarly, multiplying a body of 2 particles and a body of 3 particles together basically "plants" the body of 2 particles upon the soil of the other 3 particles. The former 2 particles are like a pair of flowers we decided to plant in each pot, and the latter 3 particles are like a group of 3 pots, each of which is to be occupied by a pair of flowers. The result will be 6 flowers in total.

(2)(3) = 2(1) + 2(1) + 2(1) = 6(1) = 6

<109>

We can multiply anti-particles as well. When we multiply a body of 2 particles and a body of 3 anti-particles together, we are basically planting a pair of flowers in every one of the 3 anti-pots. Whenever we put a flower seed upon the soil of an anti-pot, it grows to become an anti-flower instead of a regular flower (i.e. Its petals are all inverted, etc). The result will be 6 anti-flowers (i.e. "-6 flowers") in total.

2(-3) = 2(-1) + 2(-1) + 2(-1) = 6(-1) = -6

<110>

We can multiply a body of anti-particles with yet another body of anti-particles as well. Suppose that we decided to plant a pair of anti-flowers in each of 3 anti-pots. In each anti-pot, an anti-flower seed grows to become an anti-anti-flower. Since an anti-anti-flower is the same thing as just a regular flower, we will eventually see 6 regular flowers in total.

(-2)(-3) = (-2)(-1) + (-2)(-1) + (-2)(-1) = (-6)(-1) = 6(-1)(-1) = 6(1) = 6

<111>

Previously, I have demonstrated that each body of particles (such as a biscuit) can have its own identity as long as they are endowed with a unique identifier such as "ID". Assigning an identifier can be done by means of multiplication, since the identifier itself is a particle with its own unique name (e.g. "ID").

When we multiply a body of 2 particles and a body of a single "ID" particle together, we are planting a pair of flowers in a single pot marked by the name "ID". So, when the two flowers eventually grow upon the soil of this special pot, we will be able to refer to these two flowers as "ID flowers" instead of just random, anonymous flowers that can be found anywhere in the garden. Each of these two special flowers will be named "ID" because their pot's name is "ID".

2 ID = ID + ID

<112>

What if we decide to plant these two "ID flowers" in a brand new pot whose name is also "ID"? The result is not too difficult to predict. When we plant a pair of "ID flowers" in an "ID pot", the pot will grow a pair of "ID flowers" and then attach an additional "ID" prefix to each of their names. This will turn them into a pair of "ID ID flowers", or, to put it in a more succinct manner, a pair of "ID flowers".

(2 ID) ID = 2 (ID ID) = 2 ID = ID + ID

<113>

What I have portrayed so far will give you the general idea of what multiplication does. Whenever we multiply two objects, we are begetting the children of one object inside the womb of the other object.

Multiplication of particles is a useful concept not only in the realm of pure numerical quantities, but also in the world of magic. If you are an undergraduate wizard who is majoring in Sorcery Engineering, you should pay attention to the fact that particles and their products of multiplication are the most basic building blocks of modern magic.

For example, you can enchant a biscuit by following the three steps below:

(1) Generate an enchantment aura.
(2) Hold this aura with your wand.
(3) Point your wand to the biscuit, and cast the "multiply" spell. This will enchant the biscuit by wrapping it with the enchantment aura.

RESULT: (biscuit enchantment) = "enchanted biscuit"

<114>

It is equally feasible to enchant a biscuit AND curse it also, since nothing prevents us from wrapping a biscuit with two layers of aura. You can do it by following the steps shown below:

(1) Generate an enchantment aura.
(2) Hold this aura with your wand.
(3) Point your wand to the biscuit, and cast the "multiply" spell. This will enchant the biscuit by wrapping it with the enchantment aura.
(4) Generate a curse aura.
(5) Hold this aura with your wand.
(6) Point your wand to the enchanted biscuit, and cast the "multiply" spell. This will curse the enchanted biscuit by wrapping it with the curse aura.

RESULT: (biscuit enchantment curse) = "enchanted and cursed biscuit"

<115>

Just as a pure biscuit (i.e. biscuit without any aura) is an independent object, an enchanted biscuit is also an independent object. When we put these two objects together by adding them, therefore, their internal organs do not mix up in any way. These two objects, as a pair of rigid bodies, simply hold each other's hand, like a pair of magnets.

biscuit + biscuit enchantment = (1 + enchantment) biscuit

<116>

Let us go back to the conveyor belt analogy. In this peculiar model, we saw that each "position" upon the surface of the belt could be identified by a distinct power (i.e. repeated multiplication) of a variable called "ID".

What really happened here is that we put the belt's first (frontmost) object inside an ID aura, put this whole thing inside yet another ID aura (alongside the second object), and put this even bigger thing inside yet another ID aura, and so forth.

Thus, we could say that a conveyor belt which is made out of N discrete locations may as well be described as a body of N layers of ID aura, each of which contains each location's occupying object.

cookie ID + biscuit ID + dough ID = (cookie ID + biscuit ID + dough) ID = ((cookie ID + biscuit) ID + dough) ID

<117>

The same logic applies to other types of aura as well. For example, you can technically enchant an already enchanted biscuit, turning it into an "enchanted biscuit" (i.e. "enchanted-squared biscuit"), and so on. If you enchant a whole sequence of biscuits with varying degrees of enchantment (That is, you enchant the 1st biscuit only once, enchant the 2nd biscuit twice, etc), you will be left with an "enchantment belt" of biscuits.

(Will be continued in Part 10)